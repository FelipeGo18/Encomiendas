<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/hfad/encomiendas/core/AsignadorService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/hfad/encomiendas/core/AsignadorService.java" />
              <option name="originalContent" value="package com.hfad.encomiendas.core;&#10;&#10;import android.content.Context;&#10;&#10;import com.hfad.encomiendas.data.AppDatabase;&#10;import com.hfad.encomiendas.data.Asignacion;&#10;import com.hfad.encomiendas.data.Manifiesto;&#10;import com.hfad.encomiendas.data.ManifiestoItem;&#10;import com.hfad.encomiendas.data.Recolector;&#10;import com.hfad.encomiendas.data.Solicitud;&#10;&#10;import java.text.SimpleDateFormat;&#10;import java.util.ArrayList;&#10;import java.util.Date;&#10;import java.util.List;&#10;import java.util.Locale;&#10;&#10;public class AsignadorService {&#10;    private final AppDatabase db;&#10;    private final Context context;&#10;&#10;    public AsignadorService(Context ctx) {&#10;        this.context = ctx.getApplicationContext();&#10;        this.db = AppDatabase.getInstance(ctx);&#10;    }&#10;&#10;    /** Asigna todas las pendientes de una zona al recolector de esa zona (si existe). */&#10;    public int generarRutasParaFechaZona(String fecha, String zona) {&#10;        if (fecha == null || fecha.trim().isEmpty()) fecha = yyyymmdd(System.currentTimeMillis());&#10;        if (zona == null) zona = &quot;&quot;;&#10;&#10;        Recolector r = db.recolectorDao().findByZona(zona);&#10;        if (r == null) {&#10;            List&lt;Recolector&gt; all = db.recolectorDao().listAll();&#10;            if (all == null || all.isEmpty()) return 0;&#10;            r = all.get(0);&#10;        }&#10;        return generarRutasParaFechaZonaForRecolector(fecha, zona,  r.id);&#10;    }&#10;&#10;    /** Asigna las pendientes de la zona/fecha al recolector indicado, ordenadas por proximidad (greedy + 2-opt). */&#10;    public int generarRutasParaFechaZonaForRecolector(String fecha, String zona, int recolectorId) {&#10;        if (fecha == null || fecha.trim().isEmpty()) fecha = yyyymmdd(System.currentTimeMillis());&#10;        if (zona == null) zona = &quot;&quot;;&#10;&#10;        List&lt;Solicitud&gt; list = db.solicitudDao().listUnassignedByFechaZona(fecha, zona);&#10;        android.util.Log.d(&quot;ASIG&quot;, &quot;pendientes zona=&quot; + zona + &quot; fecha=&quot; + fecha + &quot; -&gt; &quot; + (list==null?0:list.size()));&#10;&#10;        if (list == null || list.isEmpty()) return 0;&#10;&#10;        List&lt;Solicitud&gt; withLL = new ArrayList&lt;&gt;();&#10;        for (Solicitud s : list) {&#10;            if (s != null &amp;&amp; s.lat != null &amp;&amp; s.lon != null &amp;&amp; s.lat != 0 &amp;&amp; s.lon != 0) withLL.add(s);&#10;        }&#10;        if (withLL.isEmpty()) return 0;&#10;&#10;        // Orden inicial greedy&#10;        List&lt;Solicitud&gt; orden = greedyOrder(withLL);&#10;        // Optimización ligera 2-opt&#10;        orden = twoOptImprove(orden, 40);&#10;        final List&lt;Solicitud&gt; finalOrden = orden; // hacer efectivamente final para la lambda&#10;&#10;        final int[] nInserted = {0};&#10;        final String fFecha = fecha;&#10;        final int fRecolectorId = recolectorId;&#10;&#10;        db.runInTransaction(() -&gt; {&#10;            int ordenRuta = 1;&#10;            List&lt;Asignacion&gt; nuevas = new ArrayList&lt;&gt;();&#10;            for (Solicitud s : finalOrden) {&#10;                Asignacion a = new Asignacion();&#10;                a.solicitudId  = (int) s.id;&#10;                a.recolectorId = fRecolectorId;&#10;                a.ordenRuta    = ordenRuta++;&#10;                a.guiaActiva   = false;&#10;                a.estado       = &quot;ASIGNADA&quot;;&#10;                a.fecha        = fFecha;&#10;                a.createdAt    = System.currentTimeMillis();&#10;                nuevas.add(a);&#10;            }&#10;            db.asignacionDao().insertAll(nuevas);&#10;            for (Solicitud s : finalOrden) {&#10;                db.solicitudDao().asignar(s.id, fRecolectorId);&#10;&#10;                // CREAR TRACKING EVENT INICIAL AUTOMÁTICAMENTE CON UBICACIÓN REAL DEL RECOLECTOR&#10;                // Esto garantiza que el remitente vea inmediatamente la ubicación REAL del recolector&#10;                if (s.lat != null &amp;&amp; s.lon != null) {&#10;                    com.hfad.encomiendas.data.TrackingEvent trackingInicial = new com.hfad.encomiendas.data.TrackingEvent();&#10;                    trackingInicial.shipmentId = s.id;&#10;&#10;                    // OBTENER LA UBICACIÓN REAL DEL RECOLECTOR (NO SIMULADA)&#10;                    Recolector recolector = db.recolectorDao().getById(fRecolectorId);&#10;                    Double latRecolector = null;&#10;                    Double lonRecolector = null;&#10;&#10;                    if (recolector != null &amp;&amp; recolector.lat != null &amp;&amp; recolector.lon != null) {&#10;                        // USAR LA UBICACIÓN REAL DEL RECOLECTOR ALMACENADA EN LA BD&#10;                        latRecolector = recolector.lat;&#10;                        lonRecolector = recolector.lon;&#10;&#10;                        android.util.Log.d(&quot;ASIG&quot;, &quot;✓ Usando ubicación REAL del recolector &quot; + recolector.nombre +&#10;                            &quot;: &quot; + latRecolector + &quot;,&quot; + lonRecolector +&#10;                            &quot; (última actualización: &quot; + (recolector.lastSeenMillis != null ?&#10;                                new java.text.SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;, java.util.Locale.getDefault())&#10;                                    .format(new java.util.Date(recolector.lastSeenMillis)) : &quot;desconocida&quot;) + &quot;)&quot;);&#10;                    } else {&#10;                        // FALLBACK: Si no hay ubicación real, usar ubicación cerca del destino&#10;                        double[] ubicacionFallback = generarUbicacionRecolectorInicial(s.lat, s.lon);&#10;                        latRecolector = ubicacionFallback[0];&#10;                        lonRecolector = ubicacionFallback[1];&#10;&#10;                        android.util.Log.w(&quot;ASIG&quot;, &quot;⚠ Recolector sin ubicación real, usando fallback cerca del destino: &quot; +&#10;                            latRecolector + &quot;,&quot; + lonRecolector);&#10;                    }&#10;&#10;                    trackingInicial.lat = latRecolector;&#10;                    trackingInicial.lon = lonRecolector;&#10;                    trackingInicial.type = &quot;ASIGNADO&quot;;&#10;                    trackingInicial.detail = &quot;Recolector asignado - &quot; +&#10;                        (recolector != null ? recolector.nombre : &quot;Recolector&quot;) +&#10;                        &quot; se dirige a recoger el paquete&quot;;&#10;&#10;                    // TIMESTAMP PRECISO&#10;                    long ahora = System.currentTimeMillis();&#10;                    trackingInicial.occurredAt = new java.text.SimpleDateFormat(&quot;yyyy-MM-dd'T'HH:mm:ss'Z'&quot;, java.util.Locale.getDefault())&#10;                            .format(new java.util.Date(ahora));&#10;&#10;                    // Insertar el evento de tracking&#10;                    long trackingId = db.trackingEventDao().insert(trackingInicial);&#10;&#10;                    android.util.Log.d(&quot;ASIG&quot;, &quot;✓ Tracking inicial creado (ID: &quot; + trackingId + &quot;) para solicitud &quot; + s.id +&#10;                            &quot; - Recolector ubicado en: &quot; + trackingInicial.lat + &quot;,&quot; + trackingInicial.lon +&#10;                            &quot; - Timestamp: &quot; + trackingInicial.occurredAt);&#10;                }&#10;            }&#10;            nInserted[0] = nuevas.size();&#10;        });&#10;        android.util.Log.d(&quot;ASIG&quot;, &quot;insertadas=&quot; + nInserted[0] + &quot; para recolector=&quot; + fRecolectorId);&#10;&#10;        com.hfad.encomiendas.core.NotificationHelper.showAssignments(&#10;                context,&#10;                &quot;Asignaciones listas&quot;,&#10;                &quot;Se generaron &quot; + nInserted[0] + &quot; recolecciones para la zona &quot; + zona + &quot;.&quot;,&#10;                (&quot;asig_&quot; + fecha + &quot;_&quot; + zona).hashCode()&#10;        );&#10;        com.hfad.encomiendas.core.NotificationHelper.notifyRecolector(&#10;                context, fRecolectorId, zona, fFecha, nInserted[0]&#10;        );&#10;        return nInserted[0];&#10;    }&#10;&#10;    private String generarCodigoManifiestoUnico() {&#10;        String base = new java.text.SimpleDateFormat(&quot;yyyyMMdd&quot;, java.util.Locale.getDefault()).format(new java.util.Date());&#10;        int intento = 1;&#10;        while (intento &lt; 10_000) {&#10;            String codigo = &quot;M-&quot; + base + &quot;-&quot; + String.format(java.util.Locale.getDefault(), &quot;%04d&quot;, intento);&#10;            if (db.manifiestoDao().countByCodigo(codigo) == 0) return codigo;&#10;            intento++;&#10;        }&#10;        return &quot;M-&quot; + base + &quot;-XXXX&quot;;&#10;    }&#10;&#10;    /**&#10;     * Asigna una ruta ya ordenada (lista de solicitudes) al recolector indicado.&#10;     * Además crea un Manifiesto y sus ManifiestoItems para persistir la ruta.&#10;     */&#10;    public int assignRutaOrdenada(String fecha,&#10;                                  int recolectorId,&#10;                                  List&lt;Solicitud&gt; orden,&#10;                                  Long horaInicioMillisOpt,&#10;                                  boolean notificarRuta) {&#10;        if (orden == null || orden.isEmpty()) return 0;&#10;        final String fFecha = (fecha == null || fecha.trim().isEmpty()) ? yyyymmdd(System.currentTimeMillis()) : fecha;&#10;        final int fRecolector = recolectorId;&#10;        final List&lt;Solicitud&gt; copia = new ArrayList&lt;&gt;();&#10;        for (Solicitud s : orden) {&#10;            if (s != null &amp;&amp; s.lat != null &amp;&amp; s.lon != null &amp;&amp; s.lat != 0 &amp;&amp; s.lon != 0) copia.add(s);&#10;        }&#10;        if (copia.isEmpty()) return 0;&#10;&#10;        double distanciaTotalM = com.hfad.encomiendas.core.GeoUtils.pathDistance(copia);&#10;        String polyline = com.hfad.encomiendas.core.GeoUtils.encodePolyline(copia);&#10;        long startPlan = (horaInicioMillisOpt == null) ? (System.currentTimeMillis() + 10 * 60_000) : horaInicioMillisOpt;&#10;        final int[] inserted = {0};&#10;        final int[] manifiestoId = {0};&#10;&#10;        db.runInTransaction(() -&gt; {&#10;            // Crear Manifiesto&#10;            Manifiesto m = new Manifiesto();&#10;            m.codigo = generarCodigoManifiestoUnico();&#10;            m.fechaMillis = System.currentTimeMillis();&#10;            m.zoneId = null; // si se asigna a zona polígono, establecer antes de llamar&#10;            m.paradas = copia.size();&#10;            m.distanciaTotalM = (int) Math.round(distanciaTotalM);&#10;            // duración heurística: 3 min por parada + 1 min cada 800m&#10;            int duracion = (int) (copia.size() * 3 + (distanciaTotalM / 800.0));&#10;            m.duracionEstimadaMin = duracion;&#10;            m.polylineEncoded = polyline;&#10;            m.horaInicioPlanificada = startPlan;&#10;            m.estado = &quot;ABIERTO&quot;;&#10;            m.createdAt = System.currentTimeMillis();&#10;            manifiestoId[0] = (int) db.manifiestoDao().insertManifiesto(m);&#10;&#10;            // Crear items manifiesto + asignaciones legacy&#10;            int idx = 1;&#10;            List&lt;Asignacion&gt; nuevas = new ArrayList&lt;&gt;();&#10;            List&lt;ManifiestoItem&gt; items = new ArrayList&lt;&gt;();&#10;            for (Solicitud s : copia) {&#10;                Asignacion a = new Asignacion();&#10;                a.solicitudId = (int) s.id;&#10;                a.recolectorId = fRecolector;&#10;                a.fecha = fFecha;&#10;                a.estado = &quot;ASIGNADA&quot;;&#10;                a.ordenRuta = idx;&#10;                a.guiaActiva = false;&#10;                a.createdAt = System.currentTimeMillis();&#10;                nuevas.add(a);&#10;&#10;                ManifiestoItem mi = new ManifiestoItem();&#10;                mi.manifiestoId = manifiestoId[0];&#10;                mi.solicitudId = s.id;&#10;                mi.orden = idx;&#10;                mi.estado = &quot;EN_HUB&quot;; // estado inicial&#10;                mi.createdAt = System.currentTimeMillis();&#10;                items.add(mi);&#10;                idx++;&#10;            }&#10;            db.asignacionDao().insertAll(nuevas);&#10;            db.manifiestoDao().insertItems(items);&#10;            for (Solicitud s : copia) db.solicitudDao().asignar(s.id, fRecolector);&#10;            inserted[0] = nuevas.size();&#10;        });&#10;&#10;        if (notificarRuta &amp;&amp; inserted[0] &gt; 0) {&#10;            com.hfad.encomiendas.core.NotificationHelper.notifyRecolectorRutaEnriquecida(&#10;                    context,&#10;                    recolectorId,&#10;                    manifiestoId[0],&#10;                    distanciaTotalM,&#10;                    startPlan,&#10;                    inserted[0]&#10;            );&#10;        }&#10;        return inserted[0];&#10;    }&#10;&#10;    // ---- Orden greedy por proximidad ----&#10;    private static List&lt;Solicitud&gt; greedyOrder(List&lt;Solicitud&gt; input) {&#10;        List&lt;Solicitud&gt; pool = new ArrayList&lt;&gt;(input);&#10;        List&lt;Solicitud&gt; out  = new ArrayList&lt;&gt;();&#10;        if (pool.isEmpty()) return out;&#10;&#10;        double cx=0, cy=0; int n=0;&#10;        for (Solicitud s : pool) { cx += s.lat; cy += s.lon; n++; }&#10;        double cLat = cx/n, cLon = cy/n;&#10;&#10;        Solicitud current = pool.get(0);&#10;        double best = Double.MAX_VALUE;&#10;        for (Solicitud s : pool) {&#10;            double d = dist(cLat,cLon,s.lat,s.lon);&#10;            if (d &lt; best) { best = d; current = s; }&#10;        }&#10;        out.add(current); pool.remove(current);&#10;&#10;        while (!pool.isEmpty()) {&#10;            Solicitud next = pool.get(0); double bestD = Double.MAX_VALUE;&#10;            for (Solicitud s : pool) {&#10;                double d = dist(current.lat,current.lon,s.lat,s.lon);&#10;                if (d &lt; bestD) { bestD = d; next = s; }&#10;            }&#10;            out.add(next); pool.remove(next); current = next;&#10;        }&#10;        return out;&#10;    }&#10;&#10;    // ---- 2-Opt mejora local de la ruta ----&#10;    private static List&lt;Solicitud&gt; twoOptImprove(List&lt;Solicitud&gt; route, int maxIterations) {&#10;        if (route.size() &lt; 4) return route; // nada que optimizar seriamente&#10;        List&lt;Solicitud&gt; best = new ArrayList&lt;&gt;(route);&#10;        double bestDist = totalDistance(best);&#10;        boolean improved;&#10;        int iter = 0;&#10;        do {&#10;            improved = false;&#10;            for (int i = 1; i &lt; best.size() - 2; i++) {&#10;                for (int k = i + 1; k &lt; best.size() - 1; k++) {&#10;                    List&lt;Solicitud&gt; candidate = twoOptSwap(best, i, k);&#10;                    double candDist = totalDistance(candidate);&#10;                    if (candDist + 0.0001 &lt; bestDist) { // margen flotante&#10;                        best = candidate;&#10;                        bestDist = candDist;&#10;                        improved = true;&#10;                    }&#10;                }&#10;            }&#10;            iter++;&#10;        } while (improved &amp;&amp; iter &lt; maxIterations);&#10;        return best;&#10;    }&#10;&#10;    private static List&lt;Solicitud&gt; twoOptSwap(List&lt;Solicitud&gt; route, int i, int k) {&#10;        List&lt;Solicitud&gt; out = new ArrayList&lt;&gt;();&#10;        // 0..i-1 igual&#10;        for (int c = 0; c &lt; i; c++) out.add(route.get(c));&#10;        // i..k invertido&#10;        for (int c = k; c &gt;= i; c--) out.add(route.get(c));&#10;        // k+1 .. end igual&#10;        for (int c = k + 1; c &lt; route.size(); c++) out.add(route.get(c));&#10;        return out;&#10;    }&#10;&#10;    private static double totalDistance(List&lt;Solicitud&gt; list) {&#10;        double sum = 0.0;&#10;        for (int i = 0; i &lt; list.size() - 1; i++) {&#10;            Solicitud a = list.get(i);&#10;            Solicitud b = list.get(i + 1);&#10;            sum += dist(a.lat, a.lon, b.lat, b.lon);&#10;        }&#10;        return sum;&#10;    }&#10;&#10;    private static double dist(double lat1, double lon1, double lat2, double lon2) {&#10;        double R=6371.0;&#10;        double dLat=Math.toRadians(lat2-lat1), dLon=Math.toRadians(lon2-lon1);&#10;        double a = Math.sin(dLat/2)*Math.sin(dLat/2)&#10;                + Math.cos(Math.toRadians(lat1))*Math.cos(Math.toRadians(lat2))&#10;                * Math.sin(dLon/2)*Math.sin(dLon/2);&#10;        return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));&#10;    }&#10;&#10;    private static String yyyymmdd(long ms){&#10;        return new SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault()).format(new Date(ms));&#10;    }&#10;&#10;    /**&#10;     * Genera una ubicación mejorada para el recolector, teniendo en cuenta su ubicación actual si está disponible.&#10;     * Se espera que esta ubicación sea realista y cerca del destino pero no exactamente en él.&#10;     */&#10;    private double[] generarUbicacionRecolectorMejorada(double latDestino, double lonDestino, Recolector recolector) {&#10;        if (recolector != null &amp;&amp; recolector.lat != null &amp;&amp; recolector.lon != null) {&#10;            // Si el recolector tiene una ubicación conocida, usarla como base&#10;            // Pero moverlo un poco hacia el destino para simular que se está dirigiendo allí&#10;            double distanciaAlDestino = dist(recolector.lat, recolector.lon, latDestino, lonDestino);&#10;&#10;            if (distanciaAlDestino &lt; 5.0) { // Si está a menos de 5km del destino&#10;                // Posicionar entre su ubicación actual y el destino (75% del camino hacia el destino)&#10;                double latRecolector = recolector.lat + (latDestino - recolector.lat) * 0.75;&#10;                double lonRecolector = recolector.lon + (lonDestino - recolector.lon) * 0.75;&#10;                return new double[]{latRecolector, lonRecolector};&#10;            } else {&#10;                // Si está muy lejos, usar su ubicación actual pero con pequeño desplazamiento hacia el destino&#10;                double factor = 0.001; // ~100 metros hacia el destino&#10;                double latRecolector = recolector.lat + (latDestino - recolector.lat) * factor;&#10;                double lonRecolector = recolector.lon + (lonDestino - recolector.lon) * factor;&#10;                return new double[]{latRecolector, lonRecolector};&#10;            }&#10;        } else {&#10;            // Si no tiene ubicación conocida, usar método de ubicación inicial cerca del destino&#10;            return generarUbicacionRecolectorInicial(latDestino, lonDestino);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Genera una ubicación simulada para el recolector al momento de la asignación.&#10;     * Se espera que esté cerca del destino, pero no en el destino exacto.&#10;     */&#10;    private double[] generarUbicacionRecolectorInicial(double latDestino, double lonDestino) {&#10;        // Generar una ubicación en un radio de 200-800 metros del destino&#10;        double anguloAleatorio = Math.random() * 2 * Math.PI; // Ángulo aleatorio&#10;        double distanciaAleatoria = 0.002 + (Math.random() * 0.006); // Entre 200m y 800m aproximadamente&#10;&#10;        double latRecolector = latDestino + (distanciaAleatoria * Math.cos(anguloAleatorio));&#10;        double lonRecolector = lonDestino + (distanciaAleatoria * Math.sin(anguloAleatorio));&#10;&#10;        return new double[]{latRecolector, lonRecolector};&#10;    }&#10;&#10;    /**&#10;     * Simula el movimiento del recolector hacia el destino, generando una ubicación intermedia.&#10;     * Se utiliza para crear un evento de tracking &quot;EN_RUTA&quot; que muestre el progreso hacia el destino.&#10;     */&#10;    private double[] simularMovimientoHaciaDestino(double latInicio, double lonInicio, double latDestino, double lonDestino, double porcentaje) {&#10;        double latIntermedia = latInicio + (latDestino - latInicio) * porcentaje;&#10;        double lonIntermedia = lonInicio + (lonDestino - lonInicio) * porcentaje;&#10;        return new double[]{latIntermedia, lonIntermedia};&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.hfad.encomiendas.core;&#10;&#10;import android.content.Context;&#10;&#10;import com.hfad.encomiendas.data.AppDatabase;&#10;import com.hfad.encomiendas.data.Asignacion;&#10;import com.hfad.encomiendas.data.Manifiesto;&#10;import com.hfad.encomiendas.data.ManifiestoItem;&#10;import com.hfad.encomiendas.data.Recolector;&#10;import com.hfad.encomiendas.data.Solicitud;&#10;&#10;import java.text.SimpleDateFormat;&#10;import java.util.ArrayList;&#10;import java.util.Date;&#10;import java.util.List;&#10;import java.util.Locale;&#10;&#10;public class AsignadorService {&#10;    private final AppDatabase db;&#10;    private final Context context;&#10;&#10;    public AsignadorService(Context ctx) {&#10;        this.context = ctx.getApplicationContext();&#10;        this.db = AppDatabase.getInstance(ctx);&#10;    }&#10;&#10;    /** Asigna todas las pendientes de una zona al recolector de esa zona (si existe). */&#10;    public int generarRutasParaFechaZona(String fecha, String zona) {&#10;        if (fecha == null || fecha.trim().isEmpty()) fecha = yyyymmdd(System.currentTimeMillis());&#10;        if (zona == null) zona = &quot;&quot;;&#10;&#10;        Recolector r = db.recolectorDao().findByZona(zona);&#10;        if (r == null) {&#10;            List&lt;Recolector&gt; all = db.recolectorDao().listAll();&#10;            if (all == null || all.isEmpty()) return 0;&#10;            r = all.get(0);&#10;        }&#10;        return generarRutasParaFechaZonaForRecolector(fecha, zona,  r.id);&#10;    }&#10;&#10;    /** Asigna las pendientes de la zona/fecha al recolector indicado, ordenadas por proximidad (greedy + 2-opt). */&#10;    public int generarRutasParaFechaZonaForRecolector(String fecha, String zona, int recolectorId) {&#10;        if (fecha == null || fecha.trim().isEmpty()) fecha = yyyymmdd(System.currentTimeMillis());&#10;        if (zona == null) zona = &quot;&quot;;&#10;&#10;        List&lt;Solicitud&gt; list = db.solicitudDao().listUnassignedByFechaZona(fecha, zona);&#10;        android.util.Log.d(&quot;ASIG&quot;, &quot;pendientes zona=&quot; + zona + &quot; fecha=&quot; + fecha + &quot; -&gt; &quot; + (list==null?0:list.size()));&#10;&#10;        if (list == null || list.isEmpty()) return 0;&#10;&#10;        List&lt;Solicitud&gt; withLL = new ArrayList&lt;&gt;();&#10;        for (Solicitud s : list) {&#10;            if (s != null &amp;&amp; s.lat != null &amp;&amp; s.lon != null &amp;&amp; s.lat != 0 &amp;&amp; s.lon != 0) withLL.add(s);&#10;        }&#10;        if (withLL.isEmpty()) return 0;&#10;&#10;        // Orden inicial greedy&#10;        List&lt;Solicitud&gt; orden = greedyOrder(withLL);&#10;        // Optimización ligera 2-opt&#10;        orden = twoOptImprove(orden, 40);&#10;        final List&lt;Solicitud&gt; finalOrden = orden; // hacer efectivamente final para la lambda&#10;&#10;        final int[] nInserted = {0};&#10;        final String fFecha = fecha;&#10;        final int fRecolectorId = recolectorId;&#10;&#10;        db.runInTransaction(() -&gt; {&#10;            int ordenRuta = 1;&#10;            List&lt;Asignacion&gt; nuevas = new ArrayList&lt;&gt;();&#10;            for (Solicitud s : finalOrden) {&#10;                Asignacion a = new Asignacion();&#10;                a.solicitudId  = (int) s.id;&#10;                a.recolectorId = fRecolectorId;&#10;                a.ordenRuta    = ordenRuta++;&#10;                a.guiaActiva   = false;&#10;                a.estado       = &quot;ASIGNADA&quot;;&#10;                a.fecha        = fFecha;&#10;                a.createdAt    = System.currentTimeMillis();&#10;                nuevas.add(a);&#10;            }&#10;            db.asignacionDao().insertAll(nuevas);&#10;            for (Solicitud s : finalOrden) {&#10;                db.solicitudDao().asignar(s.id, fRecolectorId);&#10;&#10;                // CREAR TRACKING EVENT INICIAL AUTOMÁTICAMENTE CON UBICACIÓN REAL DEL RECOLECTOR&#10;                // Esto garantiza que el remitente vea inmediatamente la ubicación REAL del recolector&#10;                if (s.lat != null &amp;&amp; s.lon != null) {&#10;                    com.hfad.encomiendas.data.TrackingEvent trackingInicial = new com.hfad.encomiendas.data.TrackingEvent();&#10;                    trackingInicial.shipmentId = s.id;&#10;&#10;                    // OBTENER LA UBICACIÓN REAL DEL RECOLECTOR (NO SIMULADA)&#10;                    Recolector recolector = db.recolectorDao().getById(fRecolectorId);&#10;                    Double latRecolector = null;&#10;                    Double lonRecolector = null;&#10;&#10;                    if (recolector != null &amp;&amp; recolector.lat != null &amp;&amp; recolector.lon != null) {&#10;                        // USAR LA UBICACIÓN REAL DEL RECOLECTOR ALMACENADA EN LA BD&#10;                        latRecolector = recolector.lat;&#10;                        lonRecolector = recolector.lon;&#10;&#10;                        android.util.Log.d(&quot;ASIG&quot;, &quot;✓ Usando ubicación REAL del recolector &quot; + recolector.nombre +&#10;                            &quot;: &quot; + latRecolector + &quot;,&quot; + lonRecolector +&#10;                            &quot; (última actualización: &quot; + (recolector.lastSeenMillis != null ?&#10;                                new java.text.SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;, java.util.Locale.getDefault())&#10;                                    .format(new java.util.Date(recolector.lastSeenMillis)) : &quot;desconocida&quot;) + &quot;)&quot;);&#10;                    } else {&#10;                        // FALLBACK: Si no hay ubicación real, usar ubicación cerca del destino&#10;                        double[] ubicacionFallback = generarUbicacionRecolectorInicial(s.lat, s.lon);&#10;                        latRecolector = ubicacionFallback[0];&#10;                        lonRecolector = ubicacionFallback[1];&#10;&#10;                        android.util.Log.w(&quot;ASIG&quot;, &quot;⚠ Recolector sin ubicación real, usando fallback cerca del destino: &quot; +&#10;                            latRecolector + &quot;,&quot; + lonRecolector);&#10;                    }&#10;&#10;                    trackingInicial.lat = latRecolector;&#10;                    trackingInicial.lon = lonRecolector;&#10;                    trackingInicial.type = &quot;ASIGNADO&quot;;&#10;                    trackingInicial.detail = &quot;Recolector asignado - &quot; +&#10;                        (recolector != null ? recolector.nombre : &quot;Recolector&quot;) +&#10;                        &quot; se dirige a recoger el paquete&quot;;&#10;&#10;                    // TIMESTAMP PRECISO&#10;                    long ahora = System.currentTimeMillis();&#10;                    trackingInicial.occurredAt = new java.text.SimpleDateFormat(&quot;yyyy-MM-dd'T'HH:mm:ss'Z'&quot;, java.util.Locale.getDefault())&#10;                            .format(new java.util.Date(ahora));&#10;&#10;                    // Insertar el evento de tracking&#10;                    long trackingId = db.trackingEventDao().insert(trackingInicial);&#10;&#10;                    android.util.Log.d(&quot;ASIG&quot;, &quot;✓ Tracking inicial creado (ID: &quot; + trackingId + &quot;) para solicitud &quot; + s.id +&#10;                            &quot; - Recolector ubicado en: &quot; + trackingInicial.lat + &quot;,&quot; + trackingInicial.lon +&#10;                            &quot; - Timestamp: &quot; + trackingInicial.occurredAt);&#10;                }&#10;            }&#10;            nInserted[0] = nuevas.size();&#10;        });&#10;        android.util.Log.d(&quot;ASIG&quot;, &quot;insertadas=&quot; + nInserted[0] + &quot; para recolector=&quot; + fRecolectorId);&#10;&#10;        com.hfad.encomiendas.core.NotificationHelper.showAssignments(&#10;                context,&#10;                &quot;Asignaciones listas&quot;,&#10;                &quot;Se generaron &quot; + nInserted[0] + &quot; recolecciones para la zona &quot; + zona + &quot;.&quot;,&#10;                (&quot;asig_&quot; + fecha + &quot;_&quot; + zona).hashCode()&#10;        );&#10;        com.hfad.encomiendas.core.NotificationHelper.notifyRecolector(&#10;                context, fRecolectorId, zona, fFecha, nInserted[0]&#10;        );&#10;        &#10;        // INICIAR TRACKING CONTINUO DEL RECOLECTOR&#10;        // Esto garantiza que la ubicación del recolector se actualice continuamente&#10;        // mientras tiene solicitudes asignadas&#10;        android.util.Log.d(&quot;ASIG&quot;, &quot;Iniciando tracking continuo para recolector: &quot; + fRecolectorId);&#10;        android.content.Intent trackingIntent = new android.content.Intent(context, com.hfad.encomiendas.core.TrackingForegroundService.class);&#10;        trackingIntent.setAction(com.hfad.encomiendas.core.TrackingForegroundService.ACTION_START);&#10;        trackingIntent.putExtra(&quot;recolectorId&quot;, fRecolectorId);&#10;        &#10;        try {&#10;            if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) {&#10;                context.startForegroundService(trackingIntent);&#10;            } else {&#10;                context.startService(trackingIntent);&#10;            }&#10;            android.util.Log.d(&quot;ASIG&quot;, &quot;✓ Tracking continuo iniciado exitosamente para recolector &quot; + fRecolectorId);&#10;        } catch (Exception e) {&#10;            android.util.Log.e(&quot;ASIG&quot;, &quot;Error iniciando tracking continuo para recolector &quot; + fRecolectorId, e);&#10;        }&#10;        &#10;        return nInserted[0];&#10;    }&#10;&#10;    private String generarCodigoManifiestoUnico() {&#10;        String base = new java.text.SimpleDateFormat(&quot;yyyyMMdd&quot;, java.util.Locale.getDefault()).format(new java.util.Date());&#10;        int intento = 1;&#10;        while (intento &lt; 10_000) {&#10;            String codigo = &quot;M-&quot; + base + &quot;-&quot; + String.format(java.util.Locale.getDefault(), &quot;%04d&quot;, intento);&#10;            if (db.manifiestoDao().countByCodigo(codigo) == 0) return codigo;&#10;            intento++;&#10;        }&#10;        return &quot;M-&quot; + base + &quot;-XXXX&quot;;&#10;    }&#10;&#10;    /**&#10;     * Asigna una ruta ya ordenada (lista de solicitudes) al recolector indicado.&#10;     * Además crea un Manifiesto y sus ManifiestoItems para persistir la ruta.&#10;     */&#10;    public int assignRutaOrdenada(String fecha,&#10;                                  int recolectorId,&#10;                                  List&lt;Solicitud&gt; orden,&#10;                                  Long horaInicioMillisOpt,&#10;                                  boolean notificarRuta) {&#10;        if (orden == null || orden.isEmpty()) return 0;&#10;        final String fFecha = (fecha == null || fecha.trim().isEmpty()) ? yyyymmdd(System.currentTimeMillis()) : fecha;&#10;        final int fRecolector = recolectorId;&#10;        final List&lt;Solicitud&gt; copia = new ArrayList&lt;&gt;();&#10;        for (Solicitud s : orden) {&#10;            if (s != null &amp;&amp; s.lat != null &amp;&amp; s.lon != null &amp;&amp; s.lat != 0 &amp;&amp; s.lon != 0) copia.add(s);&#10;        }&#10;        if (copia.isEmpty()) return 0;&#10;&#10;        double distanciaTotalM = com.hfad.encomiendas.core.GeoUtils.pathDistance(copia);&#10;        String polyline = com.hfad.encomiendas.core.GeoUtils.encodePolyline(copia);&#10;        long startPlan = (horaInicioMillisOpt == null) ? (System.currentTimeMillis() + 10 * 60_000) : horaInicioMillisOpt;&#10;        final int[] inserted = {0};&#10;        final int[] manifiestoId = {0};&#10;&#10;        db.runInTransaction(() -&gt; {&#10;            // Crear Manifiesto&#10;            Manifiesto m = new Manifiesto();&#10;            m.codigo = generarCodigoManifiestoUnico();&#10;            m.fechaMillis = System.currentTimeMillis();&#10;            m.zoneId = null; // si se asigna a zona polígono, establecer antes de llamar&#10;            m.paradas = copia.size();&#10;            m.distanciaTotalM = (int) Math.round(distanciaTotalM);&#10;            // duración heurística: 3 min por parada + 1 min cada 800m&#10;            int duracion = (int) (copia.size() * 3 + (distanciaTotalM / 800.0));&#10;            m.duracionEstimadaMin = duracion;&#10;            m.polylineEncoded = polyline;&#10;            m.horaInicioPlanificada = startPlan;&#10;            m.estado = &quot;ABIERTO&quot;;&#10;            m.createdAt = System.currentTimeMillis();&#10;            manifiestoId[0] = (int) db.manifiestoDao().insertManifiesto(m);&#10;&#10;            // Crear items manifiesto + asignaciones legacy&#10;            int idx = 1;&#10;            List&lt;Asignacion&gt; nuevas = new ArrayList&lt;&gt;();&#10;            List&lt;ManifiestoItem&gt; items = new ArrayList&lt;&gt;();&#10;            for (Solicitud s : copia) {&#10;                Asignacion a = new Asignacion();&#10;                a.solicitudId = (int) s.id;&#10;                a.recolectorId = fRecolector;&#10;                a.fecha = fFecha;&#10;                a.estado = &quot;ASIGNADA&quot;;&#10;                a.ordenRuta = idx;&#10;                a.guiaActiva = false;&#10;                a.createdAt = System.currentTimeMillis();&#10;                nuevas.add(a);&#10;&#10;                ManifiestoItem mi = new ManifiestoItem();&#10;                mi.manifiestoId = manifiestoId[0];&#10;                mi.solicitudId = s.id;&#10;                mi.orden = idx;&#10;                mi.estado = &quot;EN_HUB&quot;; // estado inicial&#10;                mi.createdAt = System.currentTimeMillis();&#10;                items.add(mi);&#10;                idx++;&#10;            }&#10;            db.asignacionDao().insertAll(nuevas);&#10;            db.manifiestoDao().insertItems(items);&#10;            for (Solicitud s : copia) db.solicitudDao().asignar(s.id, fRecolector);&#10;            inserted[0] = nuevas.size();&#10;        });&#10;&#10;        if (notificarRuta &amp;&amp; inserted[0] &gt; 0) {&#10;            com.hfad.encomiendas.core.NotificationHelper.notifyRecolectorRutaEnriquecida(&#10;                    context,&#10;                    recolectorId,&#10;                    manifiestoId[0],&#10;                    distanciaTotalM,&#10;                    startPlan,&#10;                    inserted[0]&#10;            );&#10;        }&#10;        &#10;        // INICIAR TRACKING CONTINUO DEL RECOLECTOR (igual que en el otro método)&#10;        if (inserted[0] &gt; 0) {&#10;            android.util.Log.d(&quot;ASIG&quot;, &quot;Iniciando tracking continuo para recolector (ruta ordenada): &quot; + fRecolector);&#10;            android.content.Intent trackingIntent = new android.content.Intent(context, com.hfad.encomiendas.core.TrackingForegroundService.class);&#10;            trackingIntent.setAction(com.hfad.encomiendas.core.TrackingForegroundService.ACTION_START);&#10;            trackingIntent.putExtra(&quot;recolectorId&quot;, fRecolector);&#10;            &#10;            try {&#10;                if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) {&#10;                    context.startForegroundService(trackingIntent);&#10;                } else {&#10;                    context.startService(trackingIntent);&#10;                }&#10;                android.util.Log.d(&quot;ASIG&quot;, &quot;✓ Tracking continuo iniciado exitosamente para recolector (ruta ordenada) &quot; + fRecolector);&#10;            } catch (Exception e) {&#10;                android.util.Log.e(&quot;ASIG&quot;, &quot;Error iniciando tracking continuo para recolector (ruta ordenada) &quot; + fRecolector, e);&#10;            }&#10;        }&#10;        &#10;        return inserted[0];&#10;    }&#10;&#10;    // ---- Orden greedy por proximidad ----&#10;    private static List&lt;Solicitud&gt; greedyOrder(List&lt;Solicitud&gt; input) {&#10;        List&lt;Solicitud&gt; pool = new ArrayList&lt;&gt;(input);&#10;        List&lt;Solicitud&gt; out  = new ArrayList&lt;&gt;();&#10;        if (pool.isEmpty()) return out;&#10;&#10;        double cx=0, cy=0; int n=0;&#10;        for (Solicitud s : pool) { cx += s.lat; cy += s.lon; n++; }&#10;        double cLat = cx/n, cLon = cy/n;&#10;&#10;        Solicitud current = pool.get(0);&#10;        double best = Double.MAX_VALUE;&#10;        for (Solicitud s : pool) {&#10;            double d = dist(cLat,cLon,s.lat,s.lon);&#10;            if (d &lt; best) { best = d; current = s; }&#10;        }&#10;        out.add(current); pool.remove(current);&#10;&#10;        while (!pool.isEmpty()) {&#10;            Solicitud next = pool.get(0); double bestD = Double.MAX_VALUE;&#10;            for (Solicitud s : pool) {&#10;                double d = dist(current.lat,current.lon,s.lat,s.lon);&#10;                if (d &lt; bestD) { bestD = d; next = s; }&#10;            }&#10;            out.add(next); pool.remove(next); current = next;&#10;        }&#10;        return out;&#10;    }&#10;&#10;    // ---- 2-Opt mejora local de la ruta ----&#10;    private static List&lt;Solicitud&gt; twoOptImprove(List&lt;Solicitud&gt; route, int maxIterations) {&#10;        if (route.size() &lt; 4) return route; // nada que optimizar seriamente&#10;        List&lt;Solicitud&gt; best = new ArrayList&lt;&gt;(route);&#10;        double bestDist = totalDistance(best);&#10;        boolean improved;&#10;        int iter = 0;&#10;        do {&#10;            improved = false;&#10;            for (int i = 1; i &lt; best.size() - 2; i++) {&#10;                for (int k = i + 1; k &lt; best.size() - 1; k++) {&#10;                    List&lt;Solicitud&gt; candidate = twoOptSwap(best, i, k);&#10;                    double candDist = totalDistance(candidate);&#10;                    if (candDist + 0.0001 &lt; bestDist) { // margen flotante&#10;                        best = candidate;&#10;                        bestDist = candDist;&#10;                        improved = true;&#10;                    }&#10;                }&#10;            }&#10;            iter++;&#10;        } while (improved &amp;&amp; iter &lt; maxIterations);&#10;        return best;&#10;    }&#10;&#10;    private static List&lt;Solicitud&gt; twoOptSwap(List&lt;Solicitud&gt; route, int i, int k) {&#10;        List&lt;Solicitud&gt; out = new ArrayList&lt;&gt;();&#10;        // 0..i-1 igual&#10;        for (int c = 0; c &lt; i; c++) out.add(route.get(c));&#10;        // i..k invertido&#10;        for (int c = k; c &gt;= i; c--) out.add(route.get(c));&#10;        // k+1 .. end igual&#10;        for (int c = k + 1; c &lt; route.size(); c++) out.add(route.get(c));&#10;        return out;&#10;    }&#10;&#10;    private static double totalDistance(List&lt;Solicitud&gt; list) {&#10;        double sum = 0.0;&#10;        for (int i = 0; i &lt; list.size() - 1; i++) {&#10;            Solicitud a = list.get(i);&#10;            Solicitud b = list.get(i + 1);&#10;            sum += dist(a.lat, a.lon, b.lat, b.lon);&#10;        }&#10;        return sum;&#10;    }&#10;&#10;    private static double dist(double lat1, double lon1, double lat2, double lon2) {&#10;        double R=6371.0;&#10;        double dLat=Math.toRadians(lat2-lat1), dLon=Math.toRadians(lon2-lon1);&#10;        double a = Math.sin(dLat/2)*Math.sin(dLat/2)&#10;                + Math.cos(Math.toRadians(lat1))*Math.cos(Math.toRadians(lat2))&#10;                * Math.sin(dLon/2)*Math.sin(dLon/2);&#10;        return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));&#10;    }&#10;&#10;    private static String yyyymmdd(long ms){&#10;        return new SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault()).format(new Date(ms));&#10;    }&#10;&#10;    /**&#10;     * Genera una ubicación mejorada para el recolector, teniendo en cuenta su ubicación actual si está disponible.&#10;     * Se espera que esta ubicación sea realista y cerca del destino pero no exactamente en él.&#10;     */&#10;    private double[] generarUbicacionRecolectorMejorada(double latDestino, double lonDestino, Recolector recolector) {&#10;        if (recolector != null &amp;&amp; recolector.lat != null &amp;&amp; recolector.lon != null) {&#10;            // Si el recolector tiene una ubicación conocida, usarla como base&#10;            // Pero moverlo un poco hacia el destino para simular que se está dirigiendo allí&#10;            double distanciaAlDestino = dist(recolector.lat, recolector.lon, latDestino, lonDestino);&#10;&#10;            if (distanciaAlDestino &lt; 5.0) { // Si está a menos de 5km del destino&#10;                // Posicionar entre su ubicación actual y el destino (75% del camino hacia el destino)&#10;                double latRecolector = recolector.lat + (latDestino - recolector.lat) * 0.75;&#10;                double lonRecolector = recolector.lon + (lonDestino - recolector.lon) * 0.75;&#10;                return new double[]{latRecolector, lonRecolector};&#10;            } else {&#10;                // Si está muy lejos, usar su ubicación actual pero con pequeño desplazamiento hacia el destino&#10;                double factor = 0.001; // ~100 metros hacia el destino&#10;                double latRecolector = recolector.lat + (latDestino - recolector.lat) * factor;&#10;                double lonRecolector = recolector.lon + (lonDestino - recolector.lon) * factor;&#10;                return new double[]{latRecolector, lonRecolector};&#10;            }&#10;        } else {&#10;            // Si no tiene ubicación conocida, usar método de ubicación inicial cerca del destino&#10;            return generarUbicacionRecolectorInicial(latDestino, lonDestino);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Genera una ubicación simulada para el recolector al momento de la asignación.&#10;     * Se espera que esté cerca del destino, pero no en el destino exacto.&#10;     */&#10;    private double[] generarUbicacionRecolectorInicial(double latDestino, double lonDestino) {&#10;        // Generar una ubicación en un radio de 200-800 metros del destino&#10;        double anguloAleatorio = Math.random() * 2 * Math.PI; // Ángulo aleatorio&#10;        double distanciaAleatoria = 0.002 + (Math.random() * 0.006); // Entre 200m y 800m aproximadamente&#10;&#10;        double latRecolector = latDestino + (distanciaAleatoria * Math.cos(anguloAleatorio));&#10;        double lonRecolector = lonDestino + (distanciaAleatoria * Math.sin(anguloAleatorio));&#10;&#10;        return new double[]{latRecolector, lonRecolector};&#10;    }&#10;&#10;    /**&#10;     * Simula el movimiento del recolector hacia el destino, generando una ubicación intermedia.&#10;     * Se utiliza para crear un evento de tracking &quot;EN_RUTA&quot; que muestre el progreso hacia el destino.&#10;     */&#10;    private double[] simularMovimientoHaciaDestino(double latInicio, double lonInicio, double latDestino, double lonDestino, double porcentaje) {&#10;        double latIntermedia = latInicio + (latDestino - latInicio) * porcentaje;&#10;        double lonIntermedia = lonInicio + (lonDestino - lonInicio) * porcentaje;&#10;        return new double[]{latIntermedia, lonIntermedia};&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/hfad/encomiendas/ui/DetalleEntregaFragment.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/hfad/encomiendas/ui/DetalleEntregaFragment.java" />
              <option name="originalContent" value="package com.hfad.encomiendas.ui;&#10;&#10;import android.Manifest;&#10;import android.app.AlertDialog;&#10;import android.content.pm.PackageManager;&#10;import android.os.Bundle;&#10;import android.text.TextUtils;&#10;import android.view.LayoutInflater;&#10;import android.view.View;&#10;import android.view.ViewGroup;&#10;import android.widget.TextView;&#10;import android.widget.Toast;&#10;&#10;import androidx.annotation.NonNull;&#10;import androidx.annotation.Nullable;&#10;import androidx.core.content.ContextCompat;&#10;import androidx.fragment.app.Fragment;&#10;import androidx.recyclerview.widget.LinearLayoutManager;&#10;import androidx.recyclerview.widget.RecyclerView;&#10;&#10;import com.google.android.gms.location.FusedLocationProviderClient;&#10;import com.google.android.gms.location.LocationServices;&#10;import com.google.android.gms.location.Priority;&#10;import com.google.android.gms.maps.CameraUpdateFactory;&#10;import com.google.android.gms.maps.GoogleMap;&#10;import com.google.android.gms.maps.OnMapReadyCallback;&#10;import com.google.android.gms.maps.SupportMapFragment;&#10;import com.google.android.gms.maps.model.BitmapDescriptorFactory;&#10;import com.google.android.gms.maps.model.LatLng;&#10;import com.google.android.gms.maps.model.Marker;&#10;import com.google.android.gms.maps.model.MarkerOptions;&#10;import com.google.android.material.button.MaterialButton;&#10;import com.google.android.material.chip.Chip;&#10;import com.hfad.encomiendas.R;&#10;import com.hfad.encomiendas.core.DeliveryDispatcherService;&#10;import com.hfad.encomiendas.core.TrackingService;&#10;import com.hfad.encomiendas.data.AppDatabase;&#10;import com.hfad.encomiendas.data.Asignacion;&#10;import com.hfad.encomiendas.data.AsignacionDao;&#10;import com.hfad.encomiendas.data.Solicitud;&#10;import com.hfad.encomiendas.ui.adapters.TrackingAdapter;&#10;&#10;import java.text.SimpleDateFormat;&#10;import java.util.Date;&#10;import java.util.Locale;&#10;import java.util.concurrent.Executors;&#10;&#10;public class DetalleEntregaFragment extends Fragment implements OnMapReadyCallback {&#10;&#10;    private static final String ARG_ID = &quot;asignacionId&quot;;&#10;    private int asignacionId;&#10;&#10;    private TextView tvTitulo, tvEstado, tvEta;&#10;    private Chip chipDistance;&#10;    private MaterialButton btnIniciarRuta, btnEntregado;&#10;    private RecyclerView rvTimeline;&#10;    private TrackingAdapter trackingAdapter;&#10;&#10;    private TrackingService tracking;&#10;    private FusedLocationProviderClient fused;&#10;&#10;    private GoogleMap gmap;&#10;    private Marker markerCourier, markerDestino;&#10;&#10;    private long solicitudId = -1;&#10;    private Double destinoLat, destinoLon;&#10;    private String estadoAsignacion = &quot;&quot;;&#10;&#10;    private String lastEtaIso = null;&#10;    private Double lastDistanceKm = null;&#10;    private Double lastLat = null, lastLon = null;&#10;&#10;    private boolean locationUpdatesStarted = false;&#10;    private com.google.android.gms.location.LocationCallback locationCallback;&#10;&#10;    public DetalleEntregaFragment() {}&#10;&#10;    @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {&#10;        return inflater.inflate(R.layout.fragment_detalle_entrega, container, false);&#10;    }&#10;&#10;    @Override public void onCreate(@Nullable Bundle savedInstanceState) {&#10;        super.onCreate(savedInstanceState);&#10;        asignacionId = getArguments() != null ? getArguments().getInt(ARG_ID, -1) : -1;&#10;    }&#10;&#10;    @Override public void onViewCreated(@NonNull View v, @Nullable Bundle savedInstanceState) {&#10;        super.onViewCreated(v, savedInstanceState);&#10;        tvTitulo = v.findViewById(R.id.tvTitulo);&#10;        tvEstado = v.findViewById(R.id.tvEstado);&#10;        tvEta = v.findViewById(R.id.tvEta);&#10;        chipDistance = v.findViewById(R.id.chipDistance);&#10;        btnIniciarRuta = v.findViewById(R.id.btnIniciarRuta);&#10;        btnEntregado = v.findViewById(R.id.btnMarcarEntregado);&#10;        rvTimeline = v.findViewById(R.id.rvTimeline);&#10;        rvTimeline.setLayoutManager(new LinearLayoutManager(requireContext()));&#10;        trackingAdapter = new TrackingAdapter();&#10;        rvTimeline.setAdapter(trackingAdapter);&#10;&#10;        tracking = new TrackingService(AppDatabase.getInstance(requireContext()));&#10;        fused = LocationServices.getFusedLocationProviderClient(requireContext());&#10;&#10;        SupportMapFragment mapFragment = (SupportMapFragment) getChildFragmentManager().findFragmentById(R.id.map_container_entrega);&#10;        if (mapFragment == null) {&#10;            mapFragment = SupportMapFragment.newInstance();&#10;            getChildFragmentManager().beginTransaction().replace(R.id.map_container_entrega, mapFragment).commit();&#10;        }&#10;        mapFragment.getMapAsync(this);&#10;&#10;        btnIniciarRuta.setOnClickListener(v1 -&gt; iniciarRuta());&#10;        btnEntregado.setOnClickListener(v12 -&gt; marcarEntregado());&#10;&#10;        cargar();&#10;    }&#10;&#10;    private void cargar() {&#10;        Executors.newSingleThreadExecutor().execute(() -&gt; {&#10;            try {&#10;                AppDatabase db = AppDatabase.getInstance(requireContext());&#10;                Asignacion a = db.asignacionDao().getById(asignacionId);&#10;                if (a == null) { runOnUi(() -&gt; toast(&quot;Asignación no encontrada&quot;)); return; }&#10;                solicitudId = a.solicitudId;&#10;                estadoAsignacion = a.estado;&#10;&#10;                Solicitud s = db.solicitudDao().byId(solicitudId);&#10;                if (s != null) { destinoLat = s.lat; destinoLon = s.lon; }&#10;&#10;                runOnUi(() -&gt; {&#10;                    tvTitulo.setText(&quot;Entrega #&quot; + asignacionId);&#10;                    tvEstado.setText(estadoAsignacion);&#10;                    actualizarBotones();&#10;                    refreshTimeline();&#10;                });&#10;            } catch (Exception e) {&#10;                runOnUi(() -&gt; toast(&quot;Error: &quot; + e.getMessage()));&#10;            }&#10;        });&#10;    }&#10;&#10;    private void refreshTimeline() {&#10;        if (solicitudId &lt;= 0) return;&#10;        tracking.loadTimelineAndEta(solicitudId, (ev, eta) -&gt; {&#10;            if (trackingAdapter != null) trackingAdapter.submit(ev);&#10;            if (eta != null &amp;&amp; eta.eta != null) {&#10;                lastEtaIso = eta.eta;&#10;                tvEta.setText(&quot;ETA: &quot; + eta.eta);&#10;            }&#10;        });&#10;    }&#10;&#10;    private void iniciarRuta() {&#10;        if (estadoAsignacion.startsWith(&quot;OUT_FOR_DELIVERY&quot;)) return;&#10;        Executors.newSingleThreadExecutor().execute(() -&gt; {&#10;            try {&#10;                AppDatabase db = AppDatabase.getInstance(requireContext());&#10;                db.asignacionDao().marcarOutForDelivery(asignacionId);&#10;                db.solicitudDao().marcarEnRutaEntrega(solicitudId);&#10;                estadoAsignacion = &quot;OUT_FOR_DELIVERY&quot;;&#10;                // Evento&#10;                tracking.logEvent(solicitudId, &quot;OUT_FOR_DELIVERY&quot;, &quot;Repartidor en ruta&quot;, null, null, null);&#10;                runOnUi(() -&gt; {&#10;                    toast(&quot;Ruta iniciada&quot;);&#10;                    tvEstado.setText(estadoAsignacion);&#10;                    actualizarBotones();&#10;                    startLocationUpdates();&#10;                });&#10;            } catch (Exception e) {&#10;                runOnUi(() -&gt; toast(&quot;Error: &quot; + e.getMessage()));&#10;            }&#10;        });&#10;    }&#10;&#10;    private void marcarEntregado() {&#10;        if (!&quot;OUT_FOR_DELIVERY&quot;.equals(estadoAsignacion) &amp;&amp; !&quot;DISPATCHED_LAST_MILE&quot;.equals(estadoAsignacion)) return;&#10;        new AlertDialog.Builder(requireContext())&#10;                .setTitle(&quot;Confirmar entrega&quot;)&#10;                .setMessage(&quot;¿Marcar como ENTREGADO?&quot;)&#10;                .setNegativeButton(&quot;Cancelar&quot;, null)&#10;                .setPositiveButton(&quot;Sí&quot;, (d,w) -&gt; Executors.newSingleThreadExecutor().execute(() -&gt; {&#10;                    try {&#10;                        AppDatabase db = AppDatabase.getInstance(requireContext());&#10;                        db.asignacionDao().marcarEntregada(asignacionId);&#10;                        db.solicitudDao().marcarEntregada(solicitudId);&#10;                        tracking.logEvent(solicitudId, &quot;DELIVERED&quot;, &quot;Entrega confirmada&quot;, null, null, null);&#10;                        estadoAsignacion = &quot;DELIVERED&quot;;&#10;                        runOnUi(() -&gt; {&#10;                            toast(&quot;Entregado&quot;);&#10;                            tvEstado.setText(estadoAsignacion);&#10;                            stopLocationUpdates();&#10;                            actualizarBotones();&#10;                        });&#10;                    } catch (Exception ex) {&#10;                        runOnUi(() -&gt; toast(&quot;Error: &quot; + ex.getMessage()));&#10;                    }&#10;                }))&#10;                .show();&#10;    }&#10;&#10;    private void actualizarBotones() {&#10;        boolean delivered = &quot;DELIVERED&quot;.equals(estadoAsignacion);&#10;        boolean out = &quot;OUT_FOR_DELIVERY&quot;.equals(estadoAsignacion);&#10;        btnIniciarRuta.setEnabled(!delivered &amp;&amp; !out);&#10;        btnEntregado.setEnabled(out || &quot;DISPATCHED_LAST_MILE&quot;.equals(estadoAsignacion));&#10;        float a1 = btnIniciarRuta.isEnabled()?1f:0.4f; btnIniciarRuta.setAlpha(a1);&#10;        float a2 = btnEntregado.isEnabled()?1f:0.4f; btnEntregado.setAlpha(a2);&#10;    }&#10;&#10;    @Override public void onMapReady(@NonNull GoogleMap googleMap) {&#10;        gmap = googleMap;&#10;        gmap.getUiSettings().setZoomControlsEnabled(true);&#10;        addDestinoMarker();&#10;        if (&quot;OUT_FOR_DELIVERY&quot;.equals(estadoAsignacion)) startLocationUpdates();&#10;    }&#10;&#10;    private void addDestinoMarker() {&#10;        if (gmap == null || destinoLat == null || destinoLon == null) return;&#10;        if (markerDestino == null) {&#10;            markerDestino = gmap.addMarker(new MarkerOptions().position(new LatLng(destinoLat, destinoLon)).title(&quot;Destino&quot;));&#10;        }&#10;    }&#10;&#10;    private void startLocationUpdates() {&#10;        if (locationUpdatesStarted) return;&#10;        if (ContextCompat.checkSelfPermission(requireContext(), Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) return;&#10;        locationCallback = new com.google.android.gms.location.LocationCallback() {&#10;            @Override public void onLocationResult(@NonNull com.google.android.gms.location.LocationResult result) {&#10;                if (result.getLastLocation()==null) return;&#10;                double lat = result.getLastLocation().getLatitude();&#10;                double lon = result.getLastLocation().getLongitude();&#10;                lastLat = lat; lastLon = lon;&#10;                updateCourierMarker(new LatLng(lat, lon));&#10;                recalcEta(lat, lon);&#10;            }&#10;        };&#10;        com.google.android.gms.location.LocationRequest req = new com.google.android.gms.location.LocationRequest.Builder(Priority.PRIORITY_BALANCED_POWER_ACCURACY, 15000)&#10;                .setMinUpdateIntervalMillis(8000)&#10;                .build();&#10;        fused.requestLocationUpdates(req, locationCallback, requireActivity().getMainLooper());&#10;        locationUpdatesStarted = true;&#10;    }ayu&#10;&#10;    private void stopLocationUpdates() {&#10;        if (!locationUpdatesStarted || locationCallback==null) return;&#10;        fused.removeLocationUpdates(locationCallback);&#10;        locationUpdatesStarted = false;&#10;    }&#10;&#10;    private void updateCourierMarker(LatLng p) {&#10;        if (gmap == null) return;&#10;        if (markerCourier == null) {&#10;            markerCourier = gmap.addMarker(new MarkerOptions().position(p).title(&quot;Repartidor&quot;).icon(BitmapDescriptorFactory.defaultMarker(BitmapDescriptorFactory.HUE_AZURE)));&#10;            gmap.animateCamera(CameraUpdateFactory.newLatLngZoom(p, 15f));&#10;        } else {&#10;            markerCourier.setPosition(p);&#10;        }&#10;    }&#10;&#10;    private void recalcEta(double olat, double olon) {&#10;        if (destinoLat == null || destinoLon == null) return;&#10;        double km;&#10;        try { km = TrackingService.haversine(olat, olon, destinoLat, destinoLon); } catch (Exception e) { km = 5; }&#10;        if (km &lt; 0) km = 0;&#10;        lastDistanceKm = km;&#10;        if (km &lt;= 0.05) {&#10;            tvEta.setText(&quot;ETA: Arribo&quot;);&#10;            chipDistance.setText(&quot;&lt;50m&quot;);&#10;            return;&#10;        }&#10;        String etaIso = TrackingService.calcEtaIso(Math.max(0.3, km), 25);&#10;        lastEtaIso = etaIso;&#10;        String distStr = km &gt;=1 ? String.format(Locale.getDefault(),&quot;%.1f km&quot;, km) : ((int)Math.round(km*1000))+&quot; m&quot;;&#10;        tvEta.setText(&quot;ETA: &quot; + shortTime(etaIso) + &quot; (&quot; + distStr + &quot;)&quot;);&#10;        chipDistance.setText(distStr);&#10;    }&#10;&#10;    private String shortTime(String iso) {&#10;        if (iso == null) return &quot;—&quot;;&#10;        try {&#10;            SimpleDateFormat in = new SimpleDateFormat(&quot;yyyy-MM-dd'T'HH:mm:ssXXX&quot;, Locale.getDefault());&#10;            Date d = in.parse(iso);&#10;            if (d == null) return iso;&#10;            return android.text.format.DateFormat.getTimeFormat(requireContext()).format(d);&#10;        } catch (Exception e) { return iso; }&#10;    }&#10;&#10;    private void runOnUi(Runnable r){ if(!isAdded())return; requireActivity().runOnUiThread(r);}    private void toast(String s){ if(!isAdded())return; Toast.makeText(requireContext(), s, Toast.LENGTH_SHORT).show(); }&#10;&#10;    @Override public void onPause(){ super.onPause(); stopLocationUpdates(); }&#10;    @Override public void onDestroyView(){ stopLocationUpdates(); gmap=null; super.onDestroyView(); }&#10;}&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="package com.hfad.encomiendas.ui;&#10;&#10;import android.Manifest;&#10;import android.app.AlertDialog;&#10;import android.content.pm.PackageManager;&#10;import android.os.Bundle;&#10;import android.text.TextUtils;&#10;import android.view.LayoutInflater;&#10;import android.view.View;&#10;import android.view.ViewGroup;&#10;import android.widget.TextView;&#10;import android.widget.Toast;&#10;&#10;import androidx.annotation.NonNull;&#10;import androidx.annotation.Nullable;&#10;import androidx.core.content.ContextCompat;&#10;import androidx.fragment.app.Fragment;&#10;import androidx.recyclerview.widget.LinearLayoutManager;&#10;import androidx.recyclerview.widget.RecyclerView;&#10;&#10;import com.google.android.gms.location.FusedLocationProviderClient;&#10;import com.google.android.gms.location.LocationServices;&#10;import com.google.android.gms.location.Priority;&#10;import com.google.android.gms.maps.CameraUpdateFactory;&#10;import com.google.android.gms.maps.GoogleMap;&#10;import com.google.android.gms.maps.OnMapReadyCallback;&#10;import com.google.android.gms.maps.SupportMapFragment;&#10;import com.google.android.gms.maps.model.BitmapDescriptorFactory;&#10;import com.google.android.gms.maps.model.LatLng;&#10;import com.google.android.gms.maps.model.Marker;&#10;import com.google.android.gms.maps.model.MarkerOptions;&#10;import com.google.android.gms.maps.model.MapStyleOptions;&#10;import com.google.android.gms.maps.model.Polyline;&#10;import com.google.android.gms.maps.model.PolylineOptions;&#10;import com.google.android.material.button.MaterialButton;&#10;import com.google.android.material.chip.Chip;&#10;import com.hfad.encomiendas.R;&#10;import com.hfad.encomiendas.core.TrackingService;&#10;import com.hfad.encomiendas.data.AppDatabase;&#10;import com.hfad.encomiendas.data.Solicitud;&#10;import com.hfad.encomiendas.ui.adapters.TrackingAdapter;&#10;&#10;import java.text.SimpleDateFormat;&#10;import java.util.Date;&#10;import java.util.Locale;&#10;import java.util.concurrent.Executors;&#10;&#10;import okhttp3.OkHttpClient;&#10;import okhttp3.Request;&#10;import okhttp3.Response;&#10;import org.json.JSONArray;&#10;import org.json.JSONObject;&#10;import com.hfad.encomiendas.BuildConfig;&#10;&#10;public class DetalleEntregaFragment extends Fragment implements OnMapReadyCallback {&#10;&#10;    private static final String ARG_ID = &quot;asignacionId&quot;;&#10;    private int asignacionId;&#10;&#10;    private TextView tvTitulo, tvEstado, tvEta;&#10;    private Chip chipDistance;&#10;    private MaterialButton btnIniciarRuta, btnEntregado;&#10;    private RecyclerView rvTimeline;&#10;    private TrackingAdapter trackingAdapter;&#10;&#10;    private TrackingService tracking;&#10;    private FusedLocationProviderClient fused;&#10;&#10;    private GoogleMap gmap;&#10;    private Marker markerCourier, markerDestino;&#10;&#10;    private long solicitudId = -1;&#10;    private Double destinoLat, destinoLon;&#10;    private String estadoAsignacion = &quot;&quot;;&#10;&#10;    private String lastEtaIso = null;&#10;    private Double lastDistanceKm = null;&#10;    private Double lastLat = null, lastLon = null;&#10;&#10;    private boolean locationUpdatesStarted = false;&#10;    private com.google.android.gms.location.LocationCallback locationCallback;&#10;&#10;    // --- Campos añadidos para ruta/estilo ---&#10;    private Polyline rutaPolyline;&#10;    private java.util.List&lt;Polyline&gt; routeSegments = new java.util.ArrayList&lt;&gt;();&#10;    private boolean directionsRequested = false;&#10;    private Double lastRouteOriginLat = null, lastRouteOriginLon = null;&#10;    private long lastCameraFollow = 0L;&#10;    private static final long CAMERA_FOLLOW_INTERVAL_MS = 5000L;&#10;    private static final double ROUTE_REFRESH_MIN_MOVEMENT_KM = 0.5; // 500 m&#10;    private static final double CLOSE_DISTANCE_KM = 0.2; // 200 m&#10;    private boolean markerCloseApplied = false;&#10;    private final OkHttpClient httpClient = new OkHttpClient();&#10;&#10;    public DetalleEntregaFragment() {}&#10;&#10;    @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {&#10;        return inflater.inflate(R.layout.fragment_detalle_entrega, container, false);&#10;    }&#10;&#10;    @Override public void onCreate(@Nullable Bundle savedInstanceState) {&#10;        super.onCreate(savedInstanceState);&#10;        asignacionId = getArguments() != null ? getArguments().getInt(ARG_ID, -1) : -1;&#10;    }&#10;&#10;    @Override public void onViewCreated(@NonNull View v, @Nullable Bundle savedInstanceState) {&#10;        super.onViewCreated(v, savedInstanceState);&#10;        tvTitulo = v.findViewById(R.id.tvTitulo);&#10;        tvEstado = v.findViewById(R.id.tvEstado);&#10;        tvEta = v.findViewById(R.id.tvEta);&#10;        chipDistance = v.findViewById(R.id.chipDistance);&#10;        btnIniciarRuta = v.findViewById(R.id.btnIniciarRuta);&#10;        btnEntregado = v.findViewById(R.id.btnMarcarEntregado);&#10;        rvTimeline = v.findViewById(R.id.rvTimeline);&#10;        rvTimeline.setLayoutManager(new LinearLayoutManager(requireContext()));&#10;        trackingAdapter = new TrackingAdapter();&#10;        rvTimeline.setAdapter(trackingAdapter);&#10;&#10;        tracking = new TrackingService(AppDatabase.getInstance(requireContext()));&#10;        fused = LocationServices.getFusedLocationProviderClient(requireContext());&#10;&#10;        SupportMapFragment mapFragment = (SupportMapFragment) getChildFragmentManager().findFragmentById(R.id.map_container_entrega);&#10;        if (mapFragment == null) {&#10;            mapFragment = SupportMapFragment.newInstance();&#10;            getChildFragmentManager().beginTransaction().replace(R.id.map_container_entrega, mapFragment).commit();&#10;        }&#10;        mapFragment.getMapAsync(this);&#10;&#10;        btnIniciarRuta.setOnClickListener(v1 -&gt; iniciarRuta());&#10;        btnEntregado.setOnClickListener(v12 -&gt; marcarEntregado());&#10;&#10;        cargar();&#10;    }&#10;&#10;    private void cargar() {&#10;        Executors.newSingleThreadExecutor().execute(() -&gt; {&#10;            try {&#10;                AppDatabase db = AppDatabase.getInstance(requireContext());&#10;                // Recuperar asignación principal&#10;                com.hfad.encomiendas.data.Asignacion a = db.asignacionDao().getById(asignacionId);&#10;                if (a != null) {&#10;                    solicitudId = a.solicitudId;&#10;                    estadoAsignacion = a.estado != null ? a.estado : &quot;&quot;;&#10;                }&#10;                // Recuperar solicitud para coords&#10;                if (solicitudId &gt; 0) {&#10;                    Solicitud s = db.solicitudDao().byId(solicitudId);&#10;                    if (s != null) { destinoLat = s.lat; destinoLon = s.lon; }&#10;                }&#10;                runOnUi(() -&gt; {&#10;                    tvTitulo.setText(getString(R.string.title_format, asignacionId, estadoAsignacion));&#10;                    tvEstado.setText(estadoAsignacion);&#10;                    actualizarBotones();&#10;                    refreshTimeline();&#10;                });&#10;            } catch (Exception e) {&#10;                runOnUi(() -&gt; toast(&quot;Error: &quot; + e.getMessage()));&#10;            }&#10;        });&#10;    }&#10;&#10;    private void refreshTimeline() {&#10;        if (solicitudId &lt;= 0) return;&#10;        tracking.loadTimelineAndEta(solicitudId, (ev, eta) -&gt; {&#10;            if (trackingAdapter != null) trackingAdapter.submit(ev);&#10;            if (eta != null &amp;&amp; eta.eta != null) {&#10;                lastEtaIso = eta.eta;&#10;                String shortT = shortTime(eta.eta);&#10;                tvEta.setText(getString(R.string.eta_format_only, shortT));&#10;            } else {&#10;                tvEta.setText(getString(R.string.eta_unknown));&#10;            }&#10;        });&#10;    }&#10;&#10;    private void iniciarRuta() {&#10;        if (estadoAsignacion.startsWith(&quot;OUT_FOR_DELIVERY&quot;)) return;&#10;        Executors.newSingleThreadExecutor().execute(() -&gt; {&#10;            try {&#10;                AppDatabase db = AppDatabase.getInstance(requireContext());&#10;                db.asignacionDao().marcarOutForDelivery(asignacionId);&#10;                db.solicitudDao().marcarEnRutaEntrega(solicitudId);&#10;                estadoAsignacion = &quot;OUT_FOR_DELIVERY&quot;;&#10;                // Evento&#10;                tracking.logEvent(solicitudId, &quot;OUT_FOR_DELIVERY&quot;, &quot;Repartidor en ruta&quot;, null, null, null);&#10;                runOnUi(() -&gt; {&#10;                    toast(&quot;Ruta iniciada&quot;);&#10;                    tvEstado.setText(estadoAsignacion);&#10;                    actualizarBotones();&#10;                    startLocationUpdates();&#10;                });&#10;            } catch (Exception e) {&#10;                runOnUi(() -&gt; toast(&quot;Error: &quot; + e.getMessage()));&#10;            }&#10;        });&#10;    }&#10;&#10;    private void marcarEntregado() {&#10;        if (!&quot;OUT_FOR_DELIVERY&quot;.equals(estadoAsignacion) &amp;&amp; !&quot;DISPATCHED_LAST_MILE&quot;.equals(estadoAsignacion)) return;&#10;        new AlertDialog.Builder(requireContext())&#10;                .setTitle(&quot;Confirmar entrega&quot;)&#10;                .setMessage(&quot;¿Marcar como ENTREGADO?&quot;)&#10;                .setNegativeButton(&quot;Cancelar&quot;, null)&#10;                .setPositiveButton(&quot;Sí&quot;, (d,w) -&gt; Executors.newSingleThreadExecutor().execute(() -&gt; {&#10;                    try {&#10;                        AppDatabase db = AppDatabase.getInstance(requireContext());&#10;                        db.asignacionDao().marcarEntregada(asignacionId);&#10;                        db.solicitudDao().marcarEntregada(solicitudId);&#10;                        tracking.logEvent(solicitudId, &quot;DELIVERED&quot;, &quot;Entrega confirmada&quot;, null, null, null);&#10;                        estadoAsignacion = &quot;DELIVERED&quot;;&#10;                        runOnUi(() -&gt; {&#10;                            toast(&quot;Entregado&quot;); // reutilizamos literal para evitar nuevos resources&#10;                            tvEstado.setText(estadoAsignacion);&#10;                            stopLocationUpdates();&#10;                            actualizarBotones();&#10;                        });&#10;                    } catch (Exception ex) {&#10;                        runOnUi(() -&gt; toast(&quot;Error: &quot; + ex.getMessage()));&#10;                    }&#10;                }))&#10;                .show();&#10;    }&#10;&#10;    private void actualizarBotones() {&#10;        boolean delivered = &quot;DELIVERED&quot;.equals(estadoAsignacion);&#10;        boolean out = &quot;OUT_FOR_DELIVERY&quot;.equals(estadoAsignacion);&#10;        btnIniciarRuta.setEnabled(!delivered &amp;&amp; !out);&#10;        btnEntregado.setEnabled(out || &quot;DISPATCHED_LAST_MILE&quot;.equals(estadoAsignacion));&#10;        float a1 = btnIniciarRuta.isEnabled()?1f:0.4f; btnIniciarRuta.setAlpha(a1);&#10;        float a2 = btnEntregado.isEnabled()?1f:0.4f; btnEntregado.setAlpha(a2);&#10;    }&#10;&#10;    @Override public void onMapReady(@NonNull GoogleMap googleMap) {&#10;        gmap = googleMap;&#10;        gmap.getUiSettings().setZoomControlsEnabled(true);&#10;        gmap.getUiSettings().setCompassEnabled(true);&#10;        applyDarkStyleIfNeeded();&#10;        addDestinoMarker();&#10;        requestSingleCourierLocationAndCenter();&#10;        if (&quot;OUT_FOR_DELIVERY&quot;.equals(estadoAsignacion) || &quot;DISPATCHED_LAST_MILE&quot;.equals(estadoAsignacion)) startLocationUpdates();&#10;    }&#10;&#10;    // --- Estilo nocturno ---&#10;    private void applyDarkStyleIfNeeded(){&#10;        if (gmap==null) return;&#10;        int nightMask = getResources().getConfiguration().uiMode &amp; android.content.res.Configuration.UI_MODE_NIGHT_MASK;&#10;        if (nightMask == android.content.res.Configuration.UI_MODE_NIGHT_YES) {&#10;            try { gmap.setMapStyle(MapStyleOptions.loadRawResourceStyle(requireContext(), R.raw.map_dark)); } catch (Exception ignore) {}&#10;        }&#10;    }&#10;&#10;    // --- Ubicación única para centrar cámara y dibujar línea simple inicial ---&#10;    private void requestSingleCourierLocationAndCenter(){&#10;        if (fused==null || gmap==null) return;&#10;        if (ContextCompat.checkSelfPermission(requireContext(), Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) return;&#10;        fused.getCurrentLocation(Priority.PRIORITY_BALANCED_POWER_ACCURACY, null)&#10;                .addOnSuccessListener(loc -&gt; {&#10;                    if (loc==null) return;&#10;                    double lat = loc.getLatitude(); double lon = loc.getLongitude();&#10;                    lastLat = lat; lastLon = lon;&#10;                    LatLng courier = new LatLng(lat, lon);&#10;                    updateCourierMarker(courier);&#10;                    if (destinoLat!=null &amp;&amp; destinoLon!=null){&#10;                        LatLng dest = new LatLng(destinoLat, destinoLon);&#10;                        try {&#10;                            gmap.moveCamera(CameraUpdateFactory.newLatLngBounds(new com.google.android.gms.maps.model.LatLngBounds.Builder().include(courier).include(dest).build(), 120));&#10;                        } catch (Exception ex){&#10;                            gmap.moveCamera(CameraUpdateFactory.newLatLngZoom(courier, 15f));&#10;                        }&#10;                        updateRoutePolylineSimple(courier);&#10;                        tryFetchDirectionsIfNeeded(lat, lon); // precargar ruta si hay API KEY&#10;                    } else {&#10;                        gmap.moveCamera(CameraUpdateFactory.newLatLngZoom(courier, 15f));&#10;                    }&#10;                });&#10;    }&#10;&#10;    // --- Cámara sigue al repartidor cada cierto tiempo ---&#10;    private void followCameraIfNeeded(LatLng pos){&#10;        if (gmap==null || pos==null) return;&#10;        long now = System.currentTimeMillis();&#10;        if (now - lastCameraFollow &lt; CAMERA_FOLLOW_INTERVAL_MS) return;&#10;        lastCameraFollow = now;&#10;        float zoom = gmap.getCameraPosition()!=null? gmap.getCameraPosition().zoom : 15f;&#10;        try { gmap.animateCamera(CameraUpdateFactory.newLatLngZoom(pos, zoom)); } catch (Exception ignore) {}&#10;    }&#10;&#10;    private void startLocationUpdates() {&#10;        if (locationUpdatesStarted) return;&#10;        if (ContextCompat.checkSelfPermission(requireContext(), Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) return;&#10;        locationCallback = new com.google.android.gms.location.LocationCallback() {&#10;            @Override public void onLocationResult(@NonNull com.google.android.gms.location.LocationResult result) {&#10;                if (result.getLastLocation()==null) return;&#10;                double lat = result.getLastLocation().getLatitude();&#10;                double lon = result.getLastLocation().getLongitude();&#10;                lastLat = lat; lastLon = lon;&#10;                LatLng p = new LatLng(lat, lon);&#10;                updateCourierMarker(p);&#10;                recalcEta(lat, lon);&#10;                tryFetchDirectionsIfNeeded(lat, lon);&#10;            }&#10;        };&#10;        com.google.android.gms.location.LocationRequest req = new com.google.android.gms.location.LocationRequest.Builder(Priority.PRIORITY_BALANCED_POWER_ACCURACY, 12000)&#10;                .setMinUpdateIntervalMillis(6000)&#10;                .build();&#10;        fused.requestLocationUpdates(req, locationCallback, requireActivity().getMainLooper());&#10;        locationUpdatesStarted = true;&#10;    }&#10;&#10;    private void stopLocationUpdates(){&#10;        if (!locationUpdatesStarted || fused==null || locationCallback==null) return;&#10;        try { fused.removeLocationUpdates(locationCallback); } catch (Exception ignore) {}&#10;        locationUpdatesStarted = false;&#10;        locationCallback = null;&#10;    }&#10;&#10;    private void updateCourierMarker(LatLng p) {&#10;        if (gmap == null) return;&#10;        if (markerCourier == null) {&#10;            markerCourier = gmap.addMarker(new MarkerOptions().position(p).title(&quot;Repartidor&quot;).icon(BitmapDescriptorFactory.defaultMarker(BitmapDescriptorFactory.HUE_AZURE)));&#10;        } else {&#10;            markerCourier.setPosition(p);&#10;        }&#10;        followCameraIfNeeded(p);&#10;        updateRoutePolylineSimple(p);&#10;    }&#10;&#10;    private void addDestinoMarker(){&#10;        if (gmap==null || destinoLat==null || destinoLon==null) return;&#10;        LatLng dest = new LatLng(destinoLat, destinoLon);&#10;        if (markerDestino==null){&#10;            markerDestino = gmap.addMarker(new MarkerOptions()&#10;                    .position(dest)&#10;                    .title(getString(R.string.destination_label))&#10;                    .icon(BitmapDescriptorFactory.defaultMarker(BitmapDescriptorFactory.HUE_RED))&#10;            );&#10;        } else {&#10;            markerDestino.setPosition(dest);&#10;        }&#10;    }&#10;&#10;    // --- Línea simple mientras no haya ruta real ---&#10;    private void updateRoutePolylineSimple(LatLng courier){&#10;        if (gmap==null || destinoLat==null || destinoLon==null || courier==null) return;&#10;        if (directionsRequested) return; // ya se mostró ruta detallada&#10;        LatLng dest = new LatLng(destinoLat, destinoLon);&#10;        if (rutaPolyline==null){&#10;            rutaPolyline = gmap.addPolyline(new PolylineOptions().add(courier, dest).color(0xFF1565C0).width(8f));&#10;        } else {&#10;            rutaPolyline.setPoints(java.util.Arrays.asList(courier, dest));&#10;        }&#10;    }&#10;&#10;    // --- Descarga ruta de Directions con gradiente ---&#10;    private void tryFetchDirectionsIfNeeded(double origenLat, double origenLon){&#10;        if (destinoLat==null || destinoLon==null) return;&#10;        String apiKey = BuildConfig.MAPS_API_KEY;&#10;        if (TextUtils.isEmpty(apiKey)) return; // sin API KEY mantenemos línea simple&#10;        double moved = (lastRouteOriginLat!=null &amp;&amp; lastRouteOriginLon!=null) ? TrackingService.haversine(lastRouteOriginLat, lastRouteOriginLon, origenLat, origenLon) : Double.MAX_VALUE;&#10;        if (directionsRequested &amp;&amp; moved &lt; ROUTE_REFRESH_MIN_MOVEMENT_KM) return;&#10;        directionsRequested = true;&#10;        lastRouteOriginLat = origenLat; lastRouteOriginLon = origenLon;&#10;        final String url = &quot;https://maps.googleapis.com/maps/api/directions/json?origin=&quot;+origenLat+&quot;,&quot;+origenLon+&quot;&amp;destination=&quot;+destinoLat+&quot;,&quot;+destinoLon+&quot;&amp;mode=driving&amp;key=&quot;+apiKey;&#10;        Executors.newSingleThreadExecutor().execute(() -&gt; {&#10;            try {&#10;                Request rq = new Request.Builder().url(url).build();&#10;                try (Response resp = httpClient.newCall(rq).execute()) {&#10;                    if (!resp.isSuccessful()) throw new RuntimeException(&quot;HTTP &quot;+resp.code());&#10;                    String body = resp.body()!=null? resp.body().string():null;&#10;                    if (body==null) throw new RuntimeException(&quot;Sin body&quot;);&#10;                    JSONObject json = new JSONObject(body);&#10;                    JSONArray routes = json.optJSONArray(&quot;routes&quot;);&#10;                    if (routes!=null &amp;&amp; routes.length()&gt;0){&#10;                        JSONObject r0 = routes.getJSONObject(0);&#10;                        JSONObject overview = r0.optJSONObject(&quot;overview_polyline&quot;);&#10;                        if (overview!=null){&#10;                            String pts = overview.optString(&quot;points&quot;);&#10;                            java.util.List&lt;LatLng&gt; decoded = decodePoly(pts);&#10;                            runOnUi(() -&gt; drawGradientRoute(decoded));&#10;                        }&#10;                    }&#10;                }&#10;            } catch (Exception ex){&#10;                runOnUi(() -&gt; directionsRequested = false); // permitir reintento&#10;            }&#10;        });&#10;    }&#10;&#10;    private void clearRouteSegments(){&#10;        for (Polyline p : routeSegments) try { p.remove(); } catch (Exception ignore) {}&#10;        routeSegments.clear();&#10;        if (rutaPolyline!=null){ try { rutaPolyline.remove(); } catch (Exception ignore) {} rutaPolyline=null; }&#10;    }&#10;&#10;    private void drawGradientRoute(java.util.List&lt;LatLng&gt; points){&#10;        if (gmap==null || points==null || points.size()&lt;2) return;&#10;        clearRouteSegments();&#10;        int maxPts=120;&#10;        if (points.size()&gt;maxPts){&#10;            java.util.List&lt;LatLng&gt; reduced = new java.util.ArrayList&lt;&gt;();&#10;            double step = (double)(points.size()-1)/(maxPts-1);&#10;            for (int i=0;i&lt;maxPts;i++) reduced.add(points.get((int)Math.round(i*step)));&#10;            points = reduced;&#10;        }&#10;        int n = points.size();&#10;        int startColor=0xFF1565C0, endColor=0xFF2E7D32;&#10;        for (int i=0;i&lt;n-1;i++){&#10;            LatLng a = points.get(i), b = points.get(i+1);&#10;            float f = (float)i/(float)(n-2);&#10;            int c = interpolateColor(startColor, endColor, f);&#10;            Polyline seg = gmap.addPolyline(new PolylineOptions().add(a,b).color(c).width(12f).zIndex(10f));&#10;            routeSegments.add(seg);&#10;        }&#10;    }&#10;&#10;    private int interpolateColor(int c1, int c2, float f){&#10;        int a1=(c1&gt;&gt;24)&amp;0xFF,r1=(c1&gt;&gt;16)&amp;0xFF,g1=(c1&gt;&gt;8)&amp;0xFF,b1=c1&amp;0xFF;&#10;        int a2=(c2&gt;&gt;24)&amp;0xFF,r2=(c2&gt;&gt;16)&amp;0xFF,g2=(c2&gt;&gt;8)&amp;0xFF,b2=c2&amp;0xFF;&#10;        int a=(int)(a1+(a2-a1)*f), r=(int)(r1+(r2-r1)*f), g=(int)(g1+(g2-g1)*f), b=(int)(b1+(b2-b1)*f);&#10;        return (a&lt;&lt;24)|(r&lt;&lt;16)|(g&lt;&lt;8)|b;&#10;    }&#10;&#10;    private java.util.List&lt;LatLng&gt; decodePoly(String encoded){&#10;        java.util.List&lt;LatLng&gt; poly = new java.util.ArrayList&lt;&gt;();&#10;        if (encoded==null) return poly;&#10;        int len=encoded.length(), index=0, lat=0, lng=0;&#10;        while (index &lt; len){&#10;            int b, shift=0, result=0;&#10;            do { b = encoded.charAt(index++) - 63; result |= (b &amp; 0x1f) &lt;&lt; shift; shift += 5; } while (b &gt;= 0x20 &amp;&amp; index &lt; len);&#10;            int dlat = ((result &amp; 1)!=0 ? ~(result&gt;&gt;1) : (result&gt;&gt;1)); lat += dlat;&#10;            shift=0; result=0;&#10;            do { if (index&gt;=len) break; b = encoded.charAt(index++) - 63; result |= (b &amp; 0x1f) &lt;&lt; shift; shift += 5; } while (b &gt;= 0x20 &amp;&amp; index &lt; len);&#10;            int dlng = ((result &amp; 1)!=0 ? ~(result&gt;&gt;1) : (result&gt;&gt;1)); lng += dlng;&#10;            double latD = lat/1E5; double lonD = lng/1E5; poly.add(new LatLng(latD, lonD));&#10;        }&#10;        return poly;&#10;    }&#10;&#10;    // === Método ETA restaurado ===&#10;    private void recalcEta(double olat, double olon) {&#10;        if (destinoLat == null || destinoLon == null) return;&#10;        double km;&#10;        try { km = TrackingService.haversine(olat, olon, destinoLat, destinoLon); } catch (Exception e) { km = 5; }&#10;        if (km &lt; 0) km = 0;&#10;        lastDistanceKm = km;&#10;        boolean isClose = km &lt;= CLOSE_DISTANCE_KM;&#10;        if (markerCourier != null) {&#10;            if (isClose &amp;&amp; !markerCloseApplied) {&#10;                markerCourier.setIcon(BitmapDescriptorFactory.defaultMarker(BitmapDescriptorFactory.HUE_GREEN));&#10;                markerCloseApplied = true;&#10;            } else if (!isClose &amp;&amp; markerCloseApplied) {&#10;                markerCourier.setIcon(BitmapDescriptorFactory.defaultMarker(BitmapDescriptorFactory.HUE_AZURE));&#10;                markerCloseApplied = false;&#10;            }&#10;        }&#10;        if (km &lt;= 0.05) { // llegada muy cercana&#10;            if (tvEta != null)&#10;                tvEta.setText(getString(R.string.eta_format_only, getString(R.string.minutes_sub_min)));&#10;            if (chipDistance != null) chipDistance.setText(&quot;&lt;50m&quot;);&#10;            return;&#10;        }&#10;        String etaIso = TrackingService.calcEtaIso(Math.max(0.3, km), 25);&#10;        lastEtaIso = etaIso;&#10;        String etaShort = shortTime(etaIso);&#10;        java.text.DecimalFormat df = new java.text.DecimalFormat(&quot;0.0&quot;);&#10;        if (tvEta != null)&#10;            tvEta.setText(getString(R.string.eta_with_distance_format, etaShort, df.format(km)));&#10;        if (chipDistance != null) {&#10;            if (km &gt;= 1) chipDistance.setText(String.format(Locale.getDefault(), &quot;%.1f km&quot;, km));&#10;            else chipDistance.setText(String.format(Locale.getDefault(), &quot;%d m&quot;, (int) Math.round(km * 1000)));&#10;        }&#10;    }&#10;&#10;    private String shortTime(String iso) {&#10;        if (iso == null) return &quot;—&quot;;&#10;        try {&#10;            SimpleDateFormat in = new SimpleDateFormat(&quot;yyyy-MM-dd'T'HH:mm:ssXXX&quot;, Locale.getDefault());&#10;            Date d = in.parse(iso);&#10;            if (d == null) return iso;&#10;            return android.text.format.DateFormat.getTimeFormat(requireContext()).format(d);&#10;        } catch (Exception e) {&#10;            return iso;&#10;        }&#10;    }&#10;&#10;    // Helpers UI restaurados&#10;    private void runOnUi(Runnable r){ if(!isAdded()) return; requireActivity().runOnUiThread(r); }&#10;    private void toast(String s){ if(!isAdded()) return; Toast.makeText(requireContext(), s, Toast.LENGTH_SHORT).show(); }&#10;&#10;    @Override public void onPause(){ super.onPause(); stopLocationUpdates(); }&#10;    @Override public void onDestroyView(){ stopLocationUpdates(); gmap=null; super.onDestroyView(); }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/hfad/encomiendas/ui/HomeDashboardFragment.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/hfad/encomiendas/ui/HomeDashboardFragment.java" />
              <option name="originalContent" value="package com.hfad.encomiendas.ui;&#10;&#10;import android.graphics.Bitmap;&#10;import android.graphics.BitmapFactory;&#10;import android.os.Bundle;&#10;import android.os.Handler;&#10;import android.os.Looper;&#10;import android.text.TextUtils;&#10;import android.view.LayoutInflater;&#10;import android.view.View;&#10;import android.view.ViewGroup;&#10;import android.widget.ImageView;&#10;import android.widget.TextView;&#10;import android.widget.Toast;&#10;&#10;import androidx.annotation.NonNull;&#10;import androidx.annotation.Nullable;&#10;import androidx.fragment.app.Fragment;&#10;import androidx.navigation.NavController;&#10;import androidx.navigation.fragment.NavHostFragment;&#10;import androidx.recyclerview.widget.LinearLayoutManager;&#10;import androidx.recyclerview.widget.RecyclerView;&#10;import androidx.swiperefreshlayout.widget.SwipeRefreshLayout;&#10;&#10;import com.google.android.material.button.MaterialButton;&#10;import com.hfad.encomiendas.R;&#10;import com.hfad.encomiendas.core.SessionManager;&#10;import com.hfad.encomiendas.data.AppDatabase;&#10;import com.hfad.encomiendas.data.Solicitud;&#10;import com.hfad.encomiendas.data.SolicitudDao;&#10;import com.hfad.encomiendas.data.TrackingEventDao;&#10;&#10;import java.io.InputStream;&#10;import java.net.URL;&#10;import java.util.ArrayList;&#10;import java.util.Date;&#10;import java.util.LinkedHashSet;&#10;import java.util.List;&#10;import java.util.Locale;&#10;import java.util.Set;&#10;import java.util.concurrent.Executors;&#10;import java.util.regex.Matcher;&#10;import java.util.regex.Pattern;&#10;&#10;public class HomeDashboardFragment extends Fragment {&#10;&#10;    private SwipeRefreshLayout swRefresh;&#10;    private TextView tvHola, tvCountPendientes, tvCountAsignadas, tvCountRecolectadas, tvEmpty;&#10;    private RecyclerView rvSolicitudes;&#10;    private MaterialButton btnCrear;&#10;&#10;    private UltimasAdapter adapter;&#10;    private NavController navController; // cache&#10;&#10;    @Nullable&#10;    @Override&#10;    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {&#10;        return inflater.inflate(R.layout.fragment_home_dashboard, container, false);&#10;    }&#10;&#10;    @Override&#10;    public void onViewCreated(@NonNull View v, @Nullable Bundle savedInstanceState) {&#10;        super.onViewCreated(v, savedInstanceState);&#10;        swRefresh          = v.findViewById(R.id.swRefresh);&#10;        tvHola             = v.findViewById(R.id.tvHola);&#10;        tvCountPendientes  = v.findViewById(R.id.tvCountPendientes);&#10;        tvCountAsignadas   = v.findViewById(R.id.tvCountAsignadas);&#10;        tvCountRecolectadas= v.findViewById(R.id.tvCountRecolectadas);&#10;        tvEmpty            = v.findViewById(R.id.tvEmpty);&#10;        rvSolicitudes      = v.findViewById(R.id.rvSolicitudes);&#10;        btnCrear           = v.findViewById(R.id.btnCrear);&#10;&#10;        rvSolicitudes.setLayoutManager(new LinearLayoutManager(requireContext()));&#10;        adapter = new UltimasAdapter(AppDatabase.getInstance(requireContext()));&#10;        rvSolicitudes.setAdapter(adapter);&#10;&#10;        SessionManager sm = new SessionManager(requireContext());&#10;        if (!TextUtils.isEmpty(sm.getEmail())) {&#10;            tvHola.setText(&quot;¡Hola, &quot; + sm.getEmail() + &quot;!&quot;);&#10;        }&#10;&#10;        if (swRefresh != null) swRefresh.setOnRefreshListener(this::cargarPanel);&#10;        if (btnCrear != null) {&#10;            btnCrear.setOnClickListener(vw -&gt; {&#10;                NavController nav = NavHostFragment.findNavController(this);&#10;                try { nav.navigate(R.id.action_home_to_solicitar); }&#10;                catch (Exception ignore) { nav.navigate(R.id.solicitarRecoleccionFragment); }&#10;            });&#10;        }&#10;&#10;        navController = NavHostFragment.findNavController(this);&#10;        cargarPanel();&#10;    }&#10;&#10;    /* ==================== Adapter ==================== */&#10;&#10;    private static class UltimasAdapter extends RecyclerView.Adapter&lt;VH&gt; {&#10;        private final List&lt;SolicitudDao.SolicitudConEta&gt; data = new ArrayList&lt;&gt;();&#10;        private final java.text.SimpleDateFormat dfFecha = new java.text.SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault());&#10;        private final java.text.SimpleDateFormat dfHora  = new java.text.SimpleDateFormat(&quot;h:mm a&quot;, Locale.getDefault());&#10;        private final AppDatabase db;&#10;        private final List&lt;LocationCache&gt; locCache = new ArrayList&lt;&gt;();&#10;        private final Handler ui = new Handler(Looper.getMainLooper());&#10;        private static final String MAPS_KEY = &quot;&quot;; // Rellena si deseas snapshots&#10;&#10;        static class LocationCache { long solicitudId; Double lat; Double lon; String whenIso; }&#10;&#10;        UltimasAdapter(AppDatabase db) { this.db = db; }&#10;&#10;        void setData(List&lt;SolicitudDao.SolicitudConEta&gt; list) {&#10;            boolean same = (list!=null &amp;&amp; list.size()==data.size());&#10;            if (same) {&#10;                for (int i=0;i&lt;list.size();i++) if (data.get(i).s.id != list.get(i).s.id) { same = false; break; }&#10;            }&#10;            if (!same) {&#10;                data.clear(); if (list!=null) data.addAll(list); notifyDataSetChanged();&#10;            } else {&#10;                for (int i=0;i&lt;list.size();i++) data.set(i, list.get(i));&#10;                notifyItemRangeChanged(0, data.size());&#10;            }&#10;            rebuildLocCacheIds();&#10;        }&#10;        private void rebuildLocCacheIds(){&#10;            locCache.clear();&#10;            for (SolicitudDao.SolicitudConEta it: data){ LocationCache c = new LocationCache(); c.solicitudId = it.s.id; locCache.add(c);} }&#10;&#10;        void refreshLocationsAsync() {&#10;            Executors.newSingleThreadExecutor().execute(() -&gt; {&#10;                android.util.Log.d(&quot;HomeDashboard&quot;, &quot;refreshLocationsAsync iniciado - items en cache: &quot; + locCache.size());&#10;&#10;                for (LocationCache c: locCache) {&#10;                    // LÓGICA GARANTIZADA: Si hay asignación = SIEMPRE mostrar ubicación&#10;                    Double recolectorLat = null, recolectorLon = null;&#10;                    String whenIso = null;&#10;                    boolean foundAssignment = false;&#10;&#10;                    try {&#10;                        // Buscar si hay una asignación para esta solicitud&#10;                        com.hfad.encomiendas.data.Asignacion asignacion = db.asignacionDao().getBySolicitudId(c.solicitudId);&#10;                        android.util.Log.d(&quot;HomeDashboard&quot;, &quot;Solicitud &quot; + c.solicitudId + &quot; - Asignación: &quot; + (asignacion != null ? &quot;SÍ (ID: &quot; + asignacion.id + &quot;)&quot; : &quot;NO&quot;));&#10;&#10;                        if (asignacion != null) {&#10;                            foundAssignment = true;&#10;                            // HAY ASIGNACIÓN = GARANTIZAR UBICACIÓN SIEMPRE&#10;&#10;                            // Obtener coordenadas del destino&#10;                            com.hfad.encomiendas.data.Solicitud solicitud = db.solicitudDao().byId(c.solicitudId);&#10;                            android.util.Log.d(&quot;HomeDashboard&quot;, &quot;Solicitud &quot; + c.solicitudId + &quot; - Coordenadas: &quot; +&#10;                                (solicitud != null &amp;&amp; solicitud.lat != null ? solicitud.lat + &quot;,&quot; + solicitud.lon : &quot;NULL&quot;));&#10;&#10;                            if (solicitud != null &amp;&amp; solicitud.lat != null &amp;&amp; solicitud.lon != null) {&#10;&#10;                                // PASO 1: SIEMPRE usar ubicación simulada como base (GARANTIZADA)&#10;                                recolectorLat = solicitud.lat + 0.008; // ~800m al norte&#10;                                recolectorLon = solicitud.lon + 0.008; // ~800m al este&#10;                                whenIso = new java.text.SimpleDateFormat(&quot;yyyy-MM-dd'T'HH:mm:ss'Z'&quot;, java.util.Locale.getDefault())&#10;                                        .format(new java.util.Date(asignacion.createdAt));&#10;&#10;                                android.util.Log.d(&quot;HomeDashboard&quot;, &quot;Solicitud &quot; + c.solicitudId + &quot; - Ubicación SIMULADA asignada: &quot; +&#10;                                    recolectorLat + &quot;,&quot; + recolectorLon);&#10;&#10;                                // PASO 2: OPCIONAL - Si hay tracking muy reciente, reemplazar&#10;                                TrackingEventDao.LastLoc trackingLoc = db.trackingEventDao().lastLocationForShipment(c.solicitudId);&#10;                                if (trackingLoc != null &amp;&amp; trackingLoc.lat != null &amp;&amp; trackingLoc.lon != null) {&#10;                                    android.util.Log.d(&quot;HomeDashboard&quot;, &quot;Solicitud &quot; + c.solicitudId + &quot; - Tracking encontrado: &quot; +&#10;                                        trackingLoc.lat + &quot;,&quot; + trackingLoc.lon + &quot; en &quot; + trackingLoc.whenIso);&#10;&#10;                                    try {&#10;                                        java.text.SimpleDateFormat f = new java.text.SimpleDateFormat(&quot;yyyy-MM-dd'T'HH:mm:ss&quot;, java.util.Locale.getDefault());&#10;                                        long trackingTime = f.parse(trackingLoc.whenIso.replace('Z', ' ').trim().substring(0, 19)).getTime();&#10;                                        long now = System.currentTimeMillis();&#10;                                        long diffMinutes = (now - trackingTime) / (1000 * 60);&#10;&#10;                                        android.util.Log.d(&quot;HomeDashboard&quot;, &quot;Solicitud &quot; + c.solicitudId + &quot; - Tracking edad: &quot; + diffMinutes + &quot; minutos&quot;);&#10;&#10;                                        // Solo usar tracking si es MUY reciente (menos de 30 minutos)&#10;                                        if (diffMinutes &lt;= 30) {&#10;                                            recolectorLat = trackingLoc.lat;&#10;                                            recolectorLon = trackingLoc.lon;&#10;                                            whenIso = trackingLoc.whenIso;&#10;                                            android.util.Log.d(&quot;HomeDashboard&quot;, &quot;Solicitud &quot; + c.solicitudId + &quot; - Usando tracking REAL&quot;);&#10;                                        } else {&#10;                                            android.util.Log.d(&quot;HomeDashboard&quot;, &quot;Solicitud &quot; + c.solicitudId + &quot; - Tracking muy viejo, manteniendo simulada&quot;);&#10;                                        }&#10;                                    } catch (Exception parseEx) {&#10;                                        android.util.Log.w(&quot;HomeDashboard&quot;, &quot;Error parseando fecha tracking para solicitud &quot; + c.solicitudId, parseEx);&#10;                                        // Mantener la ubicación simulada&#10;                                    }&#10;                                } else {&#10;                                    android.util.Log.d(&quot;HomeDashboard&quot;, &quot;Solicitud &quot; + c.solicitudId + &quot; - Sin tracking, usando simulada&quot;);&#10;                                }&#10;                            } else {&#10;                                android.util.Log.w(&quot;HomeDashboard&quot;, &quot;Solicitud &quot; + c.solicitudId + &quot; - Sin coordenadas válidas en solicitud&quot;);&#10;                            }&#10;                        } else {&#10;                            // SIN ASIGNACIÓN = Solo mostrar si hay tracking real&#10;                            android.util.Log.d(&quot;HomeDashboard&quot;, &quot;Solicitud &quot; + c.solicitudId + &quot; - Sin asignación, buscando solo tracking&quot;);&#10;                            TrackingEventDao.LastLoc loc = db.trackingEventDao().lastLocationForShipment(c.solicitudId);&#10;                            if (loc != null &amp;&amp; loc.lat != null &amp;&amp; loc.lon != null) {&#10;                                recolectorLat = loc.lat;&#10;                                recolectorLon = loc.lon;&#10;                                whenIso = loc.whenIso;&#10;                                android.util.Log.d(&quot;HomeDashboard&quot;, &quot;Solicitud &quot; + c.solicitudId + &quot; - Tracking encontrado sin asignación&quot;);&#10;                            }&#10;                        }&#10;                    } catch (Exception e) {&#10;                        android.util.Log.e(&quot;HomeDashboard&quot;, &quot;Error procesando solicitud &quot; + c.solicitudId, e);&#10;                        // Fallback: intentar solo tracking events&#10;                        TrackingEventDao.LastLoc loc = db.trackingEventDao().lastLocationForShipment(c.solicitudId);&#10;                        if (loc != null) {&#10;                            recolectorLat = loc.lat;&#10;                            recolectorLon = loc.lon;&#10;                            whenIso = loc.whenIso;&#10;                        }&#10;                    }&#10;&#10;                    // Actualizar cache con los datos obtenidos&#10;                    if (recolectorLat != null &amp;&amp; recolectorLon != null) {&#10;                        c.lat = recolectorLat;&#10;                        c.lon = recolectorLon;&#10;                        c.whenIso = whenIso;&#10;                        android.util.Log.d(&quot;HomeDashboard&quot;, &quot;✓ Solicitud &quot; + c.solicitudId + &quot; - Cache actualizado: &quot; +&#10;                            recolectorLat + &quot;,&quot; + recolectorLon + (foundAssignment ? &quot; (CON ASIGNACIÓN)&quot; : &quot; (SIN ASIGNACIÓN)&quot;));&#10;                    } else {&#10;                        android.util.Log.w(&quot;HomeDashboard&quot;, &quot;✗ Solicitud &quot; + c.solicitudId + &quot; - Sin ubicación final&quot;);&#10;                    }&#10;                }&#10;&#10;                android.util.Log.d(&quot;HomeDashboard&quot;, &quot;refreshLocationsAsync completado, actualizando UI&quot;);&#10;&#10;                // actualizar visible - FORZAR ACTUALIZACIÓN INDIVIDUAL&#10;                if (!data.isEmpty()) {&#10;                    // post a la UI&#10;                    if (!rvRef.get().isAttachedToWindow()) {&#10;                        android.util.Log.w(&quot;HomeDashboard&quot;, &quot;RecyclerView no está attached, no se puede actualizar&quot;);&#10;                        return;&#10;                    }&#10;&#10;                    android.util.Log.d(&quot;HomeDashboard&quot;, &quot;Forzando actualización de UI en el hilo principal&quot;);&#10;                    rvRef.get().post(() -&gt; {&#10;                        android.util.Log.d(&quot;HomeDashboard&quot;, &quot;Ejecutando notifyDataSetChanged en UI thread&quot;);&#10;&#10;                        // DOBLE ESTRATEGIA: Actualizar items específicos Y dataset completo&#10;                        for (int i = 0; i &lt; data.size(); i++) {&#10;                            SolicitudDao.SolicitudConEta item = data.get(i);&#10;                            LocationCache cache = findCache(item.s.id);&#10;                            if (cache != null &amp;&amp; cache.lat != null &amp;&amp; cache.lon != null) {&#10;                                android.util.Log.d(&quot;HomeDashboard&quot;, &quot;Actualizando item &quot; + i + &quot; para solicitud &quot; + item.s.id + &quot; con ubicación &quot; + cache.lat + &quot;,&quot; + cache.lon);&#10;                                notifyItemChanged(i);&#10;                            }&#10;                        }&#10;&#10;                        // También actualizar todo el dataset&#10;                        notifyDataSetChanged();&#10;                        android.util.Log.d(&quot;HomeDashboard&quot;, &quot;notifyDataSetChanged ejecutado&quot;);&#10;                    });&#10;                }&#10;            });&#10;        }&#10;&#10;        // referencia débil al RecyclerView para post (configurada en onAttachedToRecyclerView)&#10;        private java.lang.ref.WeakReference&lt;RecyclerView&gt; rvRef = new java.lang.ref.WeakReference&lt;&gt;(null);&#10;        @Override public void onAttachedToRecyclerView(@NonNull RecyclerView rv){ super.onAttachedToRecyclerView(rv); rvRef = new java.lang.ref.WeakReference&lt;&gt;(rv);}&#10;&#10;        private LocationCache findCache(long id){ for (LocationCache c: locCache) if (c.solicitudId==id) return c; return null; }&#10;        @NonNull @Override public VH onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {&#10;            View v = LayoutInflater.from(parent.getContext())&#10;                    .inflate(R.layout.item_solicitud_dashboard, parent, false);&#10;            return new VH(v);&#10;        }&#10;&#10;        @Override&#10;        public void onBindViewHolder(@NonNull VH h, int position) {&#10;            SolicitudDao.SolicitudConEta it = data.get(position);&#10;            Solicitud s = it.s;&#10;&#10;            h.tvGuiaEstado.setText(nn(s.guia) + &quot;  •  &quot; + nn(s.estado));&#10;&#10;            String fecha = dfFecha.format(new Date(s.ventanaInicioMillis));&#10;            String hIni  = dfHora.format(new Date(s.ventanaInicioMillis));&#10;            String hFin  = dfHora.format(new Date(s.ventanaFinMillis));&#10;            h.tvRango.setText(fecha + &quot;, &quot; + hIni + &quot; - &quot; + hFin);&#10;&#10;            h.tvEta.setText(&quot;ETA: &quot; + prettyEta(it.eta));&#10;            h.tvDireccion.setText( normalizeAddress(s.direccion) );&#10;&#10;            String destino = firstNonEmpty(meta(s.notas, &quot;DestinoDir&quot;), meta(s.notas, &quot;Destino&quot;));&#10;            h.tvDestino.setText(&quot;Destino: &quot; + nn(destino));&#10;&#10;            h.itemView.setOnClickListener(v -&gt; { if (cb != null) cb.openMapa(s.id); });&#10;&#10;            LocationCache lc = findCache(s.id);&#10;            android.util.Log.d(&quot;HomeDashboard&quot;, &quot;onBindViewHolder - Solicitud &quot; + s.id + &quot; position &quot; + position + &quot; - Cache: &quot; +&#10;                (lc != null &amp;&amp; lc.lat != null ? lc.lat + &quot;,&quot; + lc.lon : &quot;NULL&quot;));&#10;&#10;            if (lc==null || lc.lat==null) {&#10;                android.util.Log.d(&quot;HomeDashboard&quot;, &quot;onBindViewHolder - Solicitud &quot; + s.id + &quot; - Cache vacío, iniciando búsqueda async&quot;);&#10;                h.tvUbicacion.setText(&quot;Ubicación: —&quot;);&#10;                h.loadSnapshot(null, null, null, MAPS_KEY);&#10;                Executors.newSingleThreadExecutor().execute(() -&gt; {&#10;                    // NUEVA LÓGICA: SIEMPRE mostrar ubicación cuando hay asignación&#10;                    Double recolectorLat = null, recolectorLon = null;&#10;                    String whenIso = null;&#10;&#10;                    try {&#10;                        // Buscar si hay una asignación para esta solicitud&#10;                        com.hfad.encomiendas.data.Asignacion asignacion = db.asignacionDao().getBySolicitudId(s.id);&#10;                        android.util.Log.d(&quot;HomeDashboard&quot;, &quot;onBindViewHolder - Solicitud &quot; + s.id + &quot; - Asignación: &quot; +&#10;                            (asignacion != null ? &quot;SÍ (ID: &quot; + asignacion.id + &quot;)&quot; : &quot;NO&quot;));&#10;&#10;                        if (asignacion != null) {&#10;                            // HAY ASIGNACIÓN = SIEMPRE MOSTRAR UBICACIÓN GARANTIZADA&#10;&#10;                            if (s.lat != null &amp;&amp; s.lon != null) {&#10;                                // ESTRATEGIA: Siempre usar ubicación simulada cerca del destino&#10;                                // Esto garantiza que SIEMPRE aparezca algo cuando hay asignación&#10;                                recolectorLat = s.lat + 0.012; // ~1.2km al norte&#10;                                recolectorLon = s.lon + 0.012; // ~1.2km al este&#10;                                whenIso = new java.text.SimpleDateFormat(&quot;yyyy-MM-dd'T'HH:mm:ss'Z'&quot;, java.util.Locale.getDefault())&#10;                                        .format(new java.util.Date(asignacion.createdAt));&#10;&#10;                                android.util.Log.d(&quot;HomeDashboard&quot;, &quot;onBindViewHolder - Solicitud &quot; + s.id + &quot; - Ubicación SIMULADA: &quot; +&#10;                                    recolectorLat + &quot;,&quot; + recolectorLon);&#10;                            }&#10;                        } else {&#10;                            // SIN ASIGNACIÓN = Solo mostrar si hay tracking real&#10;                            TrackingEventDao.LastLoc loc = db.trackingEventDao().lastLocationForShipment(s.id);&#10;                            if (loc != null &amp;&amp; loc.lat != null &amp;&amp; loc.lon != null) {&#10;                                recolectorLat = loc.lat;&#10;                                recolectorLon = loc.lon;&#10;                                whenIso = loc.whenIso;&#10;                                android.util.Log.d(&quot;HomeDashboard&quot;, &quot;onBindViewHolder - Solicitud &quot; + s.id + &quot; - Tracking encontrado&quot;);&#10;                            }&#10;                        }&#10;                    } catch (Exception e) {&#10;                        android.util.Log.e(&quot;HomeDashboard&quot;, &quot;onBindViewHolder - Error solicitud &quot; + s.id, e);&#10;                        // Fallback: intentar solo tracking events&#10;                        TrackingEventDao.LastLoc loc = db.trackingEventDao().lastLocationForShipment(s.id);&#10;                        if (loc != null) {&#10;                            recolectorLat = loc.lat;&#10;                            recolectorLon = loc.lon;&#10;                            whenIso = loc.whenIso;&#10;                        }&#10;                    }&#10;&#10;                    // Crear variables finales para la lambda&#10;                    final Double finalRecolectorLat = recolectorLat;&#10;                    final Double finalRecolectorLon = recolectorLon;&#10;                    final String finalWhenIso = whenIso;&#10;&#10;                    // Actualizar UI si se encontró ubicación&#10;                    if (finalRecolectorLat != null &amp;&amp; finalRecolectorLon != null) {&#10;                        android.util.Log.d(&quot;HomeDashboard&quot;, &quot;onBindViewHolder - Solicitud &quot; + s.id + &quot; - Actualizando UI con: &quot; +&#10;                            finalRecolectorLat + &quot;,&quot; + finalRecolectorLon);&#10;&#10;                        if (lc != null) {&#10;                            lc.lat = finalRecolectorLat;&#10;                            lc.lon = finalRecolectorLon;&#10;                            lc.whenIso = finalWhenIso;&#10;                        }&#10;                        h.itemView.post(() -&gt; {&#10;                            android.util.Log.d(&quot;HomeDashboard&quot;, &quot;onBindViewHolder - Solicitud &quot; + s.id + &quot; - Ejecutando actualización UI&quot;);&#10;                            h.tvUbicacion.setText(formatUbicacion(finalRecolectorLat, finalRecolectorLon, finalWhenIso));&#10;                            h.loadSnapshot(finalRecolectorLat, finalRecolectorLon, null, MAPS_KEY);&#10;                        });&#10;                    } else {&#10;                        android.util.Log.w(&quot;HomeDashboard&quot;, &quot;onBindViewHolder - Solicitud &quot; + s.id + &quot; - Sin ubicación para mostrar&quot;);&#10;                    }&#10;                });&#10;            } else {&#10;                android.util.Log.d(&quot;HomeDashboard&quot;, &quot;onBindViewHolder - Solicitud &quot; + s.id + &quot; - Usando cache existente: &quot; +&#10;                    lc.lat + &quot;,&quot; + lc.lon);&#10;                String textoUbicacion = formatUbicacion(lc.lat, lc.lon, lc.whenIso);&#10;                android.util.Log.d(&quot;HomeDashboard&quot;, &quot;onBindViewHolder - Solicitud &quot; + s.id + &quot; - Estableciendo texto: '&quot; + textoUbicacion + &quot;'&quot;);&#10;&#10;                // FORZAR VISIBILIDAD Y ACTUALIZACIÓN AGRESIVA DEL TEXTVIEW&#10;                h.tvUbicacion.setVisibility(View.VISIBLE);&#10;                h.tvUbicacion.setText(textoUbicacion);&#10;                h.tvUbicacion.setTextColor(0xFF000000); // Negro sólido&#10;                h.tvUbicacion.setTextSize(14); // Tamaño visible&#10;                h.tvUbicacion.invalidate();&#10;                h.tvUbicacion.requestLayout();&#10;&#10;                // FORZAR ACTUALIZACIÓN DE TODO EL CONTENEDOR&#10;                h.itemView.invalidate();&#10;                h.itemView.requestLayout();&#10;&#10;                // POST ADICIONAL PARA GARANTIZAR RENDERIZADO&#10;                h.itemView.post(() -&gt; {&#10;                    h.tvUbicacion.setVisibility(View.VISIBLE);&#10;                    h.tvUbicacion.setText(textoUbicacion);&#10;                    h.tvUbicacion.invalidate();&#10;                });&#10;&#10;                android.util.Log.d(&quot;HomeDashboard&quot;, &quot;onBindViewHolder - Solicitud &quot; + s.id + &quot; - TextView actualizado. Texto actual: '&quot; + h.tvUbicacion.getText() + &quot;'&quot;);&#10;                android.util.Log.d(&quot;HomeDashboard&quot;, &quot;onBindViewHolder - Solicitud &quot; + s.id + &quot; - TextView visibilidad: &quot; +&#10;                    (h.tvUbicacion.getVisibility() == View.VISIBLE ? &quot;VISIBLE&quot; : &quot;HIDDEN/GONE&quot;));&#10;&#10;                h.loadSnapshot(lc.lat, lc.lon, null, MAPS_KEY);&#10;            }&#10;        }&#10;&#10;        private String formatUbicacion(Double lat, Double lon, String whenIso){&#10;            android.util.Log.d(&quot;HomeDashboard&quot;, &quot;formatUbicacion llamado con: lat=&quot; + lat + &quot;, lon=&quot; + lon + &quot;, whenIso=&quot; + whenIso);&#10;&#10;            if (lat==null||lon==null) {&#10;                android.util.Log.d(&quot;HomeDashboard&quot;, &quot;formatUbicacion devolviendo: 'Ubicación: —' (coordenadas null)&quot;);&#10;                return &quot;Ubicación: —&quot;;&#10;            }&#10;&#10;            String delta = formatDelta(whenIso);&#10;            String resultado = String.format(Locale.getDefault(), &quot;Ubicación: %.5f, %.5f%s&quot;, lat, lon, delta.isEmpty()?&quot;&quot;:&quot; (&quot;+delta+&quot;)&quot;);&#10;            android.util.Log.d(&quot;HomeDashboard&quot;, &quot;formatUbicacion devolviendo: '&quot; + resultado + &quot;'&quot;);&#10;&#10;            return resultado;&#10;        }&#10;&#10;        private static String nn(String s) { return (s == null || s.trim().isEmpty()) ? &quot;—&quot; : s.trim(); }&#10;&#10;        private static String meta(String notas, String key) {&#10;            if (notas == null) return &quot;&quot;;&#10;            Pattern p = Pattern.compile(&#10;                    &quot;\\b&quot; + Pattern.quote(key) + &quot;\\s*:\\s*(.*?)\\s*(?:\\|\\s*|(?=[A-ZÁÉÍÓÚÑ][\\wÁÉÍÓÚÑáéíóúñ ]*:\\s*)|$)&quot;,&#10;                    Pattern.CASE_INSENSITIVE | Pattern.DOTALL&#10;            );&#10;            Matcher m = p.matcher(notas);&#10;            if (m.find()) return m.group(1).trim();&#10;&#10;            Pattern p2 = Pattern.compile(&quot;\\b&quot; + Pattern.quote(key) + &quot;\\s*:\\s*(.*)$&quot;,&#10;                    Pattern.CASE_INSENSITIVE | Pattern.DOTALL);&#10;            Matcher m2 = p2.matcher(notas);&#10;            return m2.find() ? m2.group(1).trim() : &quot;&quot;;&#10;        }&#10;&#10;        private static String firstNonEmpty(String... arr) {&#10;            if (arr == null) return &quot;&quot;;&#10;            for (String s : arr) if (s != null &amp;&amp; !s.trim().isEmpty()) return s.trim();&#10;            return &quot;&quot;;&#10;        }&#10;&#10;        private static String normalizeAddress(String raw) {&#10;            if (raw == null) return &quot;—&quot;;&#10;            String[] parts = raw.split(&quot;,&quot;);&#10;            List&lt;String&gt; cleaned = new ArrayList&lt;&gt;();&#10;            Set&lt;String&gt; seenCanon = new LinkedHashSet&lt;&gt;();&#10;            String prevCanon = null;&#10;&#10;            for (String p : parts) {&#10;                String t = p.trim();&#10;                if (t.isEmpty()) continue;&#10;                String canon = java.text.Normalizer.normalize(t, java.text.Normalizer.Form.NFD)&#10;                        .replaceAll(&quot;\\p{InCombiningDiacriticalMarks}+&quot;, &quot;&quot;)&#10;                        .replaceAll(&quot;[^a-zA-Z\\s]&quot;, &quot;&quot;)&#10;                        .toLowerCase(Locale.ROOT)&#10;                        .replaceAll(&quot;\\s+&quot;, &quot; &quot;)&#10;                        .trim();&#10;                if (prevCanon != null &amp;&amp; (canon.equals(prevCanon) ||&#10;                        canon.startsWith(prevCanon) || prevCanon.startsWith(canon))) continue;&#10;                if (seenCanon.contains(canon)) continue;&#10;                cleaned.add(t);&#10;                seenCanon.add(canon);&#10;                prevCanon = canon;&#10;            }&#10;            return cleaned.isEmpty() ? raw.trim() : TextUtils.join(&quot;, &quot;, cleaned);&#10;        }&#10;&#10;        private static String prettyEta(String iso){&#10;            if (iso == null || iso.trim().isEmpty()) return &quot;—&quot;;&#10;            int t = iso.indexOf('T');&#10;            if (t &gt;= 0 &amp;&amp; iso.length() &gt;= t + 6) return iso.substring(t + 1, t + 6);&#10;            return iso;&#10;        }&#10;&#10;        private static String formatDelta(String iso){&#10;            if (iso == null) return &quot;&quot;;&#10;            try {&#10;                // intento parse simple&#10;                String base = iso.replace('Z',' ').trim();&#10;                // soporta formato con zona: tomamos primeros 19 caracteres yyyy-MM-ddTHH:mm:ss&#10;                if (base.length() &gt;= 19) base = base.substring(0,19);&#10;                java.text.SimpleDateFormat f = new java.text.SimpleDateFormat(&quot;yyyy-MM-dd'T'HH:mm:ss&quot;, Locale.getDefault());&#10;                long t = f.parse(base).getTime();&#10;                long now = System.currentTimeMillis();&#10;                long diff = Math.max(0, now - t);&#10;                long mins = diff / 60000L;&#10;                if (mins &lt; 1) return &quot;hace instantes&quot;;&#10;                if (mins &lt; 60) return &quot;hace &quot; + mins + &quot; min&quot;;&#10;                long hrs = mins / 60; if (hrs &lt; 24) return &quot;hace &quot; + hrs + &quot; h&quot;;&#10;                long dias = hrs / 24; return &quot;hace &quot; + dias + &quot; d&quot;;&#10;            } catch (Exception ignore) {}&#10;            return &quot;&quot;;&#10;        }&#10;&#10;        interface ItemClick { void openMapa(long solicitudId); }&#10;        private ItemClick cb;&#10;        void setOnItemClick(ItemClick cb){ this.cb = cb; }&#10;        @Override public int getItemCount(){ return data.size(); }&#10;    }&#10;&#10;    private static class VH extends RecyclerView.ViewHolder {&#10;        TextView tvGuiaEstado, tvRango, tvEta, tvDireccion, tvDestino, tvUbicacion;&#10;        ImageView ivMap;&#10;        VH(@NonNull View itemView) {&#10;            super(itemView);&#10;            tvGuiaEstado = itemView.findViewById(R.id.tvGuiaEstado);&#10;            tvRango      = itemView.findViewById(R.id.tvRango);&#10;            tvEta        = itemView.findViewById(R.id.tvEta);&#10;            tvDireccion  = itemView.findViewById(R.id.tvDireccion);&#10;            tvDestino    = itemView.findViewById(R.id.tvDestino);&#10;            tvUbicacion  = itemView.findViewById(R.id.tvUbicacion);&#10;            ivMap        = itemView.findViewById(R.id.ivMapPreview);&#10;        }&#10;        void loadSnapshot(Double lat, Double lon, Double destLat, String key) {&#10;            if (ivMap==null) return;&#10;            if (lat==null || lon==null || key==null || key.isEmpty()) {&#10;                ivMap.setImageResource(R.drawable.ic_launcher_background);&#10;                return;&#10;            }&#10;            StringBuilder url = new StringBuilder(&quot;https://maps.googleapis.com/maps/api/staticmap?&quot;);&#10;            url.append(&quot;center=&quot;).append(lat).append(&quot;,&quot;).append(lon)&#10;               .append(&quot;&amp;zoom=13&amp;size=400x200&amp;scale=2&amp;maptype=roadmap&quot;)&#10;               .append(&quot;&amp;markers=color:blue%7C&quot;).append(lat).append(&quot;,&quot;).append(lon);&#10;            // destino opcional no implementado (sin destLon real)&#10;            url.append(&quot;&amp;key=&quot;).append(key);&#10;            new Thread(() -&gt; {&#10;                try (InputStream is = new URL(url.toString()).openStream()) {&#10;                    Bitmap bmp = BitmapFactory.decodeStream(is);&#10;                    ivMap.post(() -&gt; ivMap.setImageBitmap(bmp));&#10;                } catch (Exception ignore) {}&#10;            }).start();&#10;        }&#10;    }&#10;&#10;    // Exponer método para configurar callback tras cargar panel&#10;    private void prepararClicks() {&#10;        if (adapter != null) adapter.setOnItemClick(sid -&gt; {&#10;            if (navController != null) {&#10;                try {&#10;                    Bundle b = new Bundle(); b.putLong(&quot;solicitudId&quot;, sid);&#10;                    navController.navigate(R.id.action_home_to_solicitudMapa, b);&#10;                } catch (Exception ignored) {}&#10;            }&#10;        });&#10;    }&#10;&#10;    private void cargarPanel() {&#10;        if (swRefresh != null) swRefresh.setRefreshing(true);&#10;        Executors.newSingleThreadExecutor().execute(() -&gt; {&#10;            try {&#10;                AppDatabase db = AppDatabase.getInstance(requireContext());&#10;                SessionManager sm = new SessionManager(requireContext());&#10;                String email = sm.getEmail();&#10;                if (TextUtils.isEmpty(email)) {&#10;                    runOnUi(() -&gt; {&#10;                        if (swRefresh != null) swRefresh.setRefreshing(false);&#10;                        Toast.makeText(requireContext(), &quot;Sesión no válida&quot;, Toast.LENGTH_SHORT).show();&#10;                    });&#10;                    return;&#10;                }&#10;                com.hfad.encomiendas.data.User u = db.userDao().findByEmail(email);&#10;                if (u == null) {&#10;                    runOnUi(() -&gt; {&#10;                        if (swRefresh != null) swRefresh.setRefreshing(false);&#10;                        Toast.makeText(requireContext(), &quot;Usuario no encontrado&quot;, Toast.LENGTH_SHORT).show();&#10;                    });&#10;                    return;&#10;                }&#10;&#10;                int cPend = db.solicitudDao().countByEstado(u.id, &quot;PENDIENTE&quot;);&#10;                int cAsig = db.solicitudDao().countByEstado(u.id, &quot;ASIGNADA&quot;);&#10;                int cReco = db.solicitudDao().countByEstado(u.id, &quot;RECOLECTADA&quot;);&#10;&#10;                List&lt;SolicitudDao.SolicitudConEta&gt; ultimas = db.solicitudDao().listAllByUserWithEta(u.id, 20);&#10;&#10;                runOnUi(() -&gt; {&#10;                    tvCountPendientes.setText(String.valueOf(cPend));&#10;                    tvCountAsignadas.setText(String.valueOf(cAsig));&#10;                    tvCountRecolectadas.setText(String.valueOf(cReco));&#10;&#10;                    adapter.setData(ultimas);&#10;                    adapter.refreshLocationsAsync();&#10;                    tvEmpty.setVisibility(adapter.getItemCount() == 0 ? View.VISIBLE : View.GONE);&#10;                    if (swRefresh != null) swRefresh.setRefreshing(false);&#10;                    prepararClicks();&#10;                });&#10;&#10;            } catch (Exception e) {&#10;                runOnUi(() -&gt; {&#10;                    if (swRefresh != null) swRefresh.setRefreshing(false);&#10;                    Toast.makeText(requireContext(), &quot;Error: &quot; + e.getMessage(), Toast.LENGTH_SHORT).show();&#10;                });&#10;            }&#10;        });&#10;    }&#10;&#10;    // Optimizar MapView en reciclado&#10;    @Override&#10;    public void onDestroyView() {&#10;        super.onDestroyView();&#10;        if (rvSolicitudes != null) {&#10;            RecyclerView.Adapter a = rvSolicitudes.getAdapter();&#10;            if (a instanceof UltimasAdapter) {&#10;                // no acceso directo a los holders ya reciclados; rely en GC&#10;            }&#10;        }&#10;    }&#10;&#10;    private void runOnUi(Runnable r) { if (!isAdded()) return; requireActivity().runOnUiThread(r); }&#10;}&#10;" />
              <option name="updatedContent" value="package com.hfad.encomiendas.ui;&#10;&#10;import android.graphics.Bitmap;&#10;import android.graphics.BitmapFactory;&#10;import android.os.Bundle;&#10;import android.os.Handler;&#10;import android.os.Looper;&#10;import android.text.TextUtils;&#10;import android.view.LayoutInflater;&#10;import android.view.View;&#10;import android.view.ViewGroup;&#10;import android.widget.ImageView;&#10;import android.widget.TextView;&#10;import android.widget.Toast;&#10;&#10;import androidx.annotation.NonNull;&#10;import androidx.annotation.Nullable;&#10;import androidx.fragment.app.Fragment;&#10;import androidx.navigation.NavController;&#10;import androidx.navigation.fragment.NavHostFragment;&#10;import androidx.recyclerview.widget.LinearLayoutManager;&#10;import androidx.recyclerview.widget.RecyclerView;&#10;import androidx.swiperefreshlayout.widget.SwipeRefreshLayout;&#10;&#10;import com.google.android.material.button.MaterialButton;&#10;import com.hfad.encomiendas.R;&#10;import com.hfad.encomiendas.core.SessionManager;&#10;import com.hfad.encomiendas.data.AppDatabase;&#10;import com.hfad.encomiendas.data.Solicitud;&#10;import com.hfad.encomiendas.data.SolicitudDao;&#10;import com.hfad.encomiendas.data.TrackingEventDao;&#10;&#10;import java.io.InputStream;&#10;import java.net.URL;&#10;import java.util.ArrayList;&#10;import java.util.Date;&#10;import java.util.LinkedHashSet;&#10;import java.util.List;&#10;import java.util.Locale;&#10;import java.util.Set;&#10;import java.util.concurrent.Executors;&#10;import java.util.regex.Matcher;&#10;import java.util.regex.Pattern;&#10;&#10;public class HomeDashboardFragment extends Fragment {&#10;&#10;    private SwipeRefreshLayout swRefresh;&#10;    private TextView tvHola, tvCountPendientes, tvCountAsignadas, tvCountRecolectadas, tvEmpty;&#10;    private RecyclerView rvSolicitudes;&#10;    private MaterialButton btnCrear;&#10;&#10;    private UltimasAdapter adapter;&#10;    private NavController navController; // cache&#10;&#10;    @Nullable&#10;    @Override&#10;    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {&#10;        return inflater.inflate(R.layout.fragment_home_dashboard, container, false);&#10;    }&#10;&#10;    @Override&#10;    public void onViewCreated(@NonNull View v, @Nullable Bundle savedInstanceState) {&#10;        super.onViewCreated(v, savedInstanceState);&#10;        swRefresh          = v.findViewById(R.id.swRefresh);&#10;        tvHola             = v.findViewById(R.id.tvHola);&#10;        tvCountPendientes  = v.findViewById(R.id.tvCountPendientes);&#10;        tvCountAsignadas   = v.findViewById(R.id.tvCountAsignadas);&#10;        tvCountRecolectadas= v.findViewById(R.id.tvCountRecolectadas);&#10;        tvEmpty            = v.findViewById(R.id.tvEmpty);&#10;        rvSolicitudes      = v.findViewById(R.id.rvSolicitudes);&#10;        btnCrear           = v.findViewById(R.id.btnCrear);&#10;&#10;        rvSolicitudes.setLayoutManager(new LinearLayoutManager(requireContext()));&#10;        adapter = new UltimasAdapter(AppDatabase.getInstance(requireContext()));&#10;        rvSolicitudes.setAdapter(adapter);&#10;&#10;        SessionManager sm = new SessionManager(requireContext());&#10;        if (!TextUtils.isEmpty(sm.getEmail())) {&#10;            tvHola.setText(&quot;¡Hola, &quot; + sm.getEmail() + &quot;!&quot;);&#10;        }&#10;&#10;        if (swRefresh != null) swRefresh.setOnRefreshListener(this::cargarPanel);&#10;        if (btnCrear != null) {&#10;            btnCrear.setOnClickListener(vw -&gt; {&#10;                NavController nav = NavHostFragment.findNavController(this);&#10;                try { nav.navigate(R.id.action_home_to_solicitar); }&#10;                catch (Exception ignore) { nav.navigate(R.id.solicitarRecoleccionFragment); }&#10;            });&#10;        }&#10;&#10;        navController = NavHostFragment.findNavController(this);&#10;        cargarPanel();&#10;    }&#10;&#10;    /* ==================== Adapter ==================== */&#10;&#10;    private static class UltimasAdapter extends RecyclerView.Adapter&lt;VH&gt; {&#10;        private final List&lt;SolicitudDao.SolicitudConEta&gt; data = new ArrayList&lt;&gt;();&#10;        private final java.text.SimpleDateFormat dfFecha = new java.text.SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault());&#10;        private final java.text.SimpleDateFormat dfHora  = new java.text.SimpleDateFormat(&quot;h:mm a&quot;, Locale.getDefault());&#10;        private final AppDatabase db;&#10;        private final List&lt;LocationCache&gt; locCache = new ArrayList&lt;&gt;();&#10;        private final Handler ui = new Handler(Looper.getMainLooper());&#10;        private static final String MAPS_KEY = &quot;&quot;; // Rellena si deseas snapshots&#10;&#10;        static class LocationCache { long solicitudId; Double lat; Double lon; String whenIso; }&#10;&#10;        UltimasAdapter(AppDatabase db) { this.db = db; }&#10;&#10;        void setData(List&lt;SolicitudDao.SolicitudConEta&gt; list) {&#10;            boolean same = (list!=null &amp;&amp; list.size()==data.size());&#10;            if (same) {&#10;                for (int i=0;i&lt;list.size();i++) if (data.get(i).s.id != list.get(i).s.id) { same = false; break; }&#10;            }&#10;            if (!same) {&#10;                data.clear(); if (list!=null) data.addAll(list); notifyDataSetChanged();&#10;            } else {&#10;                for (int i=0;i&lt;list.size();i++) data.set(i, list.get(i));&#10;                notifyItemRangeChanged(0, data.size());&#10;            }&#10;            rebuildLocCacheIds();&#10;        }&#10;        private void rebuildLocCacheIds(){&#10;            locCache.clear();&#10;            for (SolicitudDao.SolicitudConEta it: data){ LocationCache c = new LocationCache(); c.solicitudId = it.s.id; locCache.add(c);} }&#10;&#10;        void refreshLocationsAsync() {&#10;            Executors.newSingleThreadExecutor().execute(() -&gt; {&#10;                android.util.Log.d(&quot;HomeDashboard&quot;, &quot;refreshLocationsAsync iniciado - items en cache: &quot; + locCache.size());&#10;&#10;                for (LocationCache c: locCache) {&#10;                    // LÓGICA GARANTIZADA: Si hay asignación = SIEMPRE mostrar ubicación&#10;                    Double recolectorLat = null, recolectorLon = null;&#10;                    String whenIso = null;&#10;                    boolean foundAssignment = false;&#10;&#10;                    try {&#10;                        // Buscar si hay una asignación para esta solicitud&#10;                        com.hfad.encomiendas.data.Asignacion asignacion = db.asignacionDao().getBySolicitudId(c.solicitudId);&#10;                        android.util.Log.d(&quot;HomeDashboard&quot;, &quot;Solicitud &quot; + c.solicitudId + &quot; - Asignación: &quot; + (asignacion != null ? &quot;SÍ (ID: &quot; + asignacion.id + &quot;)&quot; : &quot;NO&quot;));&#10;&#10;                        if (asignacion != null) {&#10;                            foundAssignment = true;&#10;                            // HAY ASIGNACIÓN = BUSCAR UBICACIÓN REAL DEL RECOLECTOR (NO DEL DESTINO)&#10;&#10;                            // PASO 1: PRIORIZAR ubicación actual del recolector desde la tabla Recolector&#10;                            com.hfad.encomiendas.data.Recolector recolector = db.recolectorDao().getById(asignacion.recolectorId);&#10;&#10;                            if (recolector != null &amp;&amp; recolector.lat != null &amp;&amp; recolector.lon != null) {&#10;                                // USAR UBICACIÓN ACTUAL DEL RECOLECTOR (actualizada por TrackingForegroundService)&#10;                                recolectorLat = recolector.lat;&#10;                                recolectorLon = recolector.lon;&#10;                                whenIso = new java.text.SimpleDateFormat(&quot;yyyy-MM-dd'T'HH:mm:ss'Z'&quot;, java.util.Locale.getDefault())&#10;                                        .format(new java.util.Date(recolector.lastSeenMillis != null ? recolector.lastSeenMillis : asignacion.createdAt));&#10;&#10;                                android.util.Log.d(&quot;HomeDashboard&quot;, &quot;Solicitud &quot; + c.solicitudId + &quot; - Ubicación ACTUAL del recolector &quot; +&#10;                                    recolector.nombre + &quot;: &quot; + recolectorLat + &quot;,&quot; + recolectorLon);&#10;                            } else {&#10;                                // PASO 2: FALLBACK - Buscar tracking event si el recolector no tiene ubicación&#10;                                TrackingEventDao.LastLoc trackingLoc = db.trackingEventDao().lastLocationForShipment(c.solicitudId);&#10;&#10;                                if (trackingLoc != null &amp;&amp; trackingLoc.lat != null &amp;&amp; trackingLoc.lon != null) {&#10;                                    // USAR TRACKING (ubicación del recolector del momento de asignación)&#10;                                    recolectorLat = trackingLoc.lat;&#10;                                    recolectorLon = trackingLoc.lon;&#10;                                    whenIso = trackingLoc.whenIso;&#10;&#10;                                    android.util.Log.d(&quot;HomeDashboard&quot;, &quot;Solicitud &quot; + c.solicitudId + &quot; - Usando tracking event del recolector: &quot; +&#10;                                        recolectorLat + &quot;,&quot; + recolectorLon + &quot; en &quot; + whenIso);&#10;                                } else {&#10;                                    // PASO 3: ÚLTIMO FALLBACK - ubicación simulada del recolector (NO del destino)&#10;                                    // Obtener las coordenadas del destino solo para calcular una ubicación cercana del recolector&#10;                                    com.hfad.encomiendas.data.Solicitud solicitud = db.solicitudDao().byId(c.solicitudId);&#10;                                    if (solicitud != null &amp;&amp; solicitud.lat != null &amp;&amp; solicitud.lon != null) {&#10;                                        // Simular que el recolector está cerca del destino pero NO en el destino&#10;                                        recolectorLat = solicitud.lat + 0.008; // ~800m al norte del destino&#10;                                        recolectorLon = solicitud.lon + 0.008; // ~800m al este del destino&#10;                                        whenIso = new java.text.SimpleDateFormat(&quot;yyyy-MM-dd'T'HH:mm:ss'Z'&quot;, java.util.Locale.getDefault())&#10;                                                .format(new java.util.Date(asignacion.createdAt));&#10;&#10;                                        android.util.Log.d(&quot;HomeDashboard&quot;, &quot;Solicitud &quot; + c.solicitudId + &quot; - Sin datos del recolector, simulando ubicación cerca del destino: &quot; +&#10;                                            recolectorLat + &quot;,&quot; + recolectorLon);&#10;                                    }&#10;                                }&#10;                            }&#10;                        } else {&#10;                            // SIN ASIGNACIÓN = Solo mostrar si hay tracking real&#10;                            android.util.Log.d(&quot;HomeDashboard&quot;, &quot;Solicitud &quot; + c.solicitudId + &quot; - Sin asignación, buscando solo tracking&quot;);&#10;                            TrackingEventDao.LastLoc loc = db.trackingEventDao().lastLocationForShipment(c.solicitudId);&#10;                            if (loc != null &amp;&amp; loc.lat != null &amp;&amp; loc.lon != null) {&#10;                                recolectorLat = loc.lat;&#10;                                recolectorLon = loc.lon;&#10;                                whenIso = loc.whenIso;&#10;                                android.util.Log.d(&quot;HomeDashboard&quot;, &quot;Solicitud &quot; + c.solicitudId + &quot; - Tracking encontrado sin asignación&quot;);&#10;                            }&#10;                        }&#10;                    } catch (Exception e) {&#10;                        android.util.Log.e(&quot;HomeDashboard&quot;, &quot;Error procesando solicitud &quot; + c.solicitudId, e);&#10;                        // Fallback: intentar solo tracking events&#10;                        TrackingEventDao.LastLoc loc = db.trackingEventDao().lastLocationForShipment(c.solicitudId);&#10;                        if (loc != null) {&#10;                            recolectorLat = loc.lat;&#10;                            recolectorLon = loc.lon;&#10;                            whenIso = loc.whenIso;&#10;                        }&#10;                    }&#10;&#10;                    // Actualizar cache con los datos obtenidos&#10;                    if (recolectorLat != null &amp;&amp; recolectorLon != null) {&#10;                        c.lat = recolectorLat;&#10;                        c.lon = recolectorLon;&#10;                        c.whenIso = whenIso;&#10;                        android.util.Log.d(&quot;HomeDashboard&quot;, &quot;✓ Solicitud &quot; + c.solicitudId + &quot; - Cache actualizado: &quot; +&#10;                            recolectorLat + &quot;,&quot; + recolectorLon + (foundAssignment ? &quot; (CON ASIGNACIÓN)&quot; : &quot; (SIN ASIGNACIÓN)&quot;));&#10;                    } else {&#10;                        android.util.Log.w(&quot;HomeDashboard&quot;, &quot;✗ Solicitud &quot; + c.solicitudId + &quot; - Sin ubicación final&quot;);&#10;                    }&#10;                }&#10;&#10;                android.util.Log.d(&quot;HomeDashboard&quot;, &quot;refreshLocationsAsync completado, actualizando UI&quot;);&#10;&#10;                // actualizar visible - FORZAR ACTUALIZACIÓN INDIVIDUAL&#10;                if (!data.isEmpty()) {&#10;                    // post a la UI&#10;                    if (!rvRef.get().isAttachedToWindow()) {&#10;                        android.util.Log.w(&quot;HomeDashboard&quot;, &quot;RecyclerView no está attached, no se puede actualizar&quot;);&#10;                        return;&#10;                    }&#10;&#10;                    android.util.Log.d(&quot;HomeDashboard&quot;, &quot;Forzando actualización de UI en el hilo principal&quot;);&#10;                    rvRef.get().post(() -&gt; {&#10;                        android.util.Log.d(&quot;HomeDashboard&quot;, &quot;Ejecutando notifyDataSetChanged en UI thread&quot;);&#10;&#10;                        // DOBLE ESTRATEGIA: Actualizar items específicos Y dataset completo&#10;                        for (int i = 0; i &lt; data.size(); i++) {&#10;                            SolicitudDao.SolicitudConEta item = data.get(i);&#10;                            LocationCache cache = findCache(item.s.id);&#10;                            if (cache != null &amp;&amp; cache.lat != null &amp;&amp; cache.lon != null) {&#10;                                android.util.Log.d(&quot;HomeDashboard&quot;, &quot;Actualizando item &quot; + i + &quot; para solicitud &quot; + item.s.id + &quot; con ubicación &quot; + cache.lat + &quot;,&quot; + cache.lon);&#10;                                notifyItemChanged(i);&#10;                            }&#10;                        }&#10;&#10;                        // También actualizar todo el dataset&#10;                        notifyDataSetChanged();&#10;                        android.util.Log.d(&quot;HomeDashboard&quot;, &quot;notifyDataSetChanged ejecutado&quot;);&#10;                    });&#10;                }&#10;            });&#10;        }&#10;&#10;        // referencia débil al RecyclerView para post (configurada en onAttachedToRecyclerView)&#10;        private java.lang.ref.WeakReference&lt;RecyclerView&gt; rvRef = new java.lang.ref.WeakReference&lt;&gt;(null);&#10;        @Override public void onAttachedToRecyclerView(@NonNull RecyclerView rv){ super.onAttachedToRecyclerView(rv); rvRef = new java.lang.ref.WeakReference&lt;&gt;(rv);}&#10;&#10;        private LocationCache findCache(long id){ for (LocationCache c: locCache) if (c.solicitudId==id) return c; return null; }&#10;        @NonNull @Override public VH onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {&#10;            View v = LayoutInflater.from(parent.getContext())&#10;                    .inflate(R.layout.item_solicitud_dashboard, parent, false);&#10;            return new VH(v);&#10;        }&#10;&#10;        @Override&#10;        public void onBindViewHolder(@NonNull VH h, int position) {&#10;            SolicitudDao.SolicitudConEta it = data.get(position);&#10;            Solicitud s = it.s;&#10;&#10;            h.tvGuiaEstado.setText(nn(s.guia) + &quot;  •  &quot; + nn(s.estado));&#10;&#10;            String fecha = dfFecha.format(new Date(s.ventanaInicioMillis));&#10;            String hIni  = dfHora.format(new Date(s.ventanaInicioMillis));&#10;            String hFin  = dfHora.format(new Date(s.ventanaFinMillis));&#10;            h.tvRango.setText(fecha + &quot;, &quot; + hIni + &quot; - &quot; + hFin);&#10;&#10;            h.tvEta.setText(&quot;ETA: &quot; + prettyEta(it.eta));&#10;            h.tvDireccion.setText( normalizeAddress(s.direccion) );&#10;&#10;            String destino = firstNonEmpty(meta(s.notas, &quot;DestinoDir&quot;), meta(s.notas, &quot;Destino&quot;));&#10;            h.tvDestino.setText(&quot;Destino: &quot; + nn(destino));&#10;&#10;            h.itemView.setOnClickListener(v -&gt; { if (cb != null) cb.openMapa(s.id); });&#10;&#10;            LocationCache lc = findCache(s.id);&#10;            android.util.Log.d(&quot;HomeDashboard&quot;, &quot;onBindViewHolder - Solicitud &quot; + s.id + &quot; position &quot; + position + &quot; - Cache: &quot; +&#10;                (lc != null &amp;&amp; lc.lat != null ? lc.lat + &quot;,&quot; + lc.lon : &quot;NULL&quot;));&#10;&#10;            if (lc==null || lc.lat==null) {&#10;                android.util.Log.d(&quot;HomeDashboard&quot;, &quot;onBindViewHolder - Solicitud &quot; + s.id + &quot; - Cache vacío, iniciando búsqueda async&quot;);&#10;                h.tvUbicacion.setText(&quot;Ubicación: —&quot;);&#10;                h.loadSnapshot(null, null, null, MAPS_KEY);&#10;                Executors.newSingleThreadExecutor().execute(() -&gt; {&#10;                    // NUEVA LÓGICA: SIEMPRE mostrar ubicación cuando hay asignación&#10;                    Double recolectorLat = null, recolectorLon = null;&#10;                    String whenIso = null;&#10;&#10;                    try {&#10;                        // Buscar si hay una asignación para esta solicitud&#10;                        com.hfad.encomiendas.data.Asignacion asignacion = db.asignacionDao().getBySolicitudId(s.id);&#10;                        android.util.Log.d(&quot;HomeDashboard&quot;, &quot;onBindViewHolder - Solicitud &quot; + s.id + &quot; - Asignación: &quot; +&#10;                            (asignacion != null ? &quot;SÍ (ID: &quot; + asignacion.id + &quot;)&quot; : &quot;NO&quot;));&#10;&#10;                        if (asignacion != null) {&#10;                            // HAY ASIGNACIÓN = PRIORIZAR TRACKING EVENT DE LA ASIGNACIÓN&#10;&#10;                            // Obtener coordenadas del destino&#10;                            com.hfad.encomiendas.data.Solicitud solicitud = db.solicitudDao().byId(s.id);&#10;                            android.util.Log.d(&quot;HomeDashboard&quot;, &quot;Solicitud &quot; + s.id + &quot; - Coordenadas: &quot; +&#10;                                (solicitud != null &amp;&amp; solicitud.lat != null ? solicitud.lat + &quot;,&quot; + solicitud.lon : &quot;NULL&quot;));&#10;&#10;                            if (solicitud != null &amp;&amp; solicitud.lat != null &amp;&amp; solicitud.lon != null) {&#10;&#10;                                // PASO 1: PRIORIZAR tracking event (contiene ubicación real del momento de asignación)&#10;                                TrackingEventDao.LastLoc trackingLoc = db.trackingEventDao().lastLocationForShipment(s.id);&#10;&#10;                                if (trackingLoc != null &amp;&amp; trackingLoc.lat != null &amp;&amp; trackingLoc.lon != null) {&#10;                                    // USAR TRACKING (ubicación real del recolector en el momento de asignación)&#10;                                    recolectorLat = trackingLoc.lat;&#10;                                    recolectorLon = trackingLoc.lon;&#10;                                    whenIso = trackingLoc.whenIso;&#10;&#10;                                    android.util.Log.d(&quot;HomeDashboard&quot;, &quot;onBindViewHolder - Solicitud &quot; + s.id + &quot; - Usando tracking event con ubicación REAL: &quot; +&#10;                                        recolectorLat + &quot;,&quot; + recolectorLon + &quot; en &quot; + whenIso);&#10;                                } else {&#10;                                    // PASO 2: FALLBACK - Buscar ubicación actual del recolector&#10;                                    com.hfad.encomiendas.data.Recolector recolector = db.recolectorDao().getById(asignacion.recolectorId);&#10;&#10;                                    if (recolector != null &amp;&amp; recolector.lat != null &amp;&amp; recolector.lon != null) {&#10;                                        // USAR UBICACIÓN ACTUAL DEL RECOLECTOR&#10;                                        recolectorLat = recolector.lat;&#10;                                        recolectorLon = recolector.lon;&#10;                                        whenIso = new java.text.SimpleDateFormat(&quot;yyyy-MM-dd'T'HH:mm:ss'Z'&quot;, java.util.Locale.getDefault())&#10;                                                .format(new java.util.Date(recolector.lastSeenMillis != null ? recolector.lastSeenMillis : asignacion.createdAt));&#10;&#10;                                        android.util.Log.d(&quot;HomeDashboard&quot;, &quot;onBindViewHolder - Solicitud &quot; + s.id + &quot; - Sin tracking, usando ubicación actual del recolector &quot; +&#10;                                            recolector.nombre + &quot;: &quot; + recolectorLat + &quot;,&quot; + recolectorLon);&#10;                                    } else {&#10;                                        // PASO 3: ÚLTIMO FALLBACK - ubicación simulada cerca del destino&#10;                                        recolectorLat = s.lat + 0.012; // ~1.2km al norte&#10;                                        recolectorLon = s.lon + 0.012; // ~1.2km al este&#10;                                        whenIso = new java.text.SimpleDateFormat(&quot;yyyy-MM-dd'T'HH:mm:ss'Z'&quot;, java.util.Locale.getDefault())&#10;                                                .format(new java.util.Date(asignacion.createdAt));&#10;&#10;                                        android.util.Log.d(&quot;HomeDashboard&quot;, &quot;onBindViewHolder - Solicitud &quot; + s.id + &quot; - Sin datos reales, usando simulada: &quot; +&#10;                                            recolectorLat + &quot;,&quot; + recolectorLon);&#10;                                    }&#10;                                }&#10;                            }&#10;                        } else {&#10;                            // SIN ASIGNACIÓN = Solo mostrar si hay tracking real&#10;                            TrackingEventDao.LastLoc loc = db.trackingEventDao().lastLocationForShipment(s.id);&#10;                            if (loc != null &amp;&amp; loc.lat != null &amp;&amp; loc.lon != null) {&#10;                                recolectorLat = loc.lat;&#10;                                recolectorLon = loc.lon;&#10;                                whenIso = loc.whenIso;&#10;                                android.util.Log.d(&quot;HomeDashboard&quot;, &quot;onBindViewHolder - Solicitud &quot; + s.id + &quot; - Tracking encontrado&quot;);&#10;                            }&#10;                        }&#10;                    } catch (Exception e) {&#10;                        android.util.Log.e(&quot;HomeDashboard&quot;, &quot;onBindViewHolder - Error solicitud &quot; + s.id, e);&#10;                        // Fallback: intentar solo tracking events&#10;                        TrackingEventDao.LastLoc loc = db.trackingEventDao().lastLocationForShipment(s.id);&#10;                        if (loc != null) {&#10;                            recolectorLat = loc.lat;&#10;                            recolectorLon = loc.lon;&#10;                            whenIso = loc.whenIso;&#10;                        }&#10;                    }&#10;&#10;                    // Crear variables finales para la lambda&#10;                    final Double finalRecolectorLat = recolectorLat;&#10;                    final Double finalRecolectorLon = recolectorLon;&#10;                    final String finalWhenIso = whenIso;&#10;&#10;                    // Actualizar UI si se encontró ubicación&#10;                    if (finalRecolectorLat != null &amp;&amp; finalRecolectorLon != null) {&#10;                        android.util.Log.d(&quot;HomeDashboard&quot;, &quot;onBindViewHolder - Solicitud &quot; + s.id + &quot; - Actualizando UI con: &quot; +&#10;                            finalRecolectorLat + &quot;,&quot; + finalRecolectorLon);&#10;&#10;                        if (lc != null) {&#10;                            lc.lat = finalRecolectorLat;&#10;                            lc.lon = finalRecolectorLon;&#10;                            lc.whenIso = finalWhenIso;&#10;                        }&#10;                        h.itemView.post(() -&gt; {&#10;                            android.util.Log.d(&quot;HomeDashboard&quot;, &quot;onBindViewHolder - Solicitud &quot; + s.id + &quot; - Ejecutando actualización UI&quot;);&#10;                            h.tvUbicacion.setText(formatUbicacion(finalRecolectorLat, finalRecolectorLon, finalWhenIso));&#10;                            h.loadSnapshot(finalRecolectorLat, finalRecolectorLon, null, MAPS_KEY);&#10;                        });&#10;                    } else {&#10;                        android.util.Log.w(&quot;HomeDashboard&quot;, &quot;onBindViewHolder - Solicitud &quot; + s.id + &quot; - Sin ubicación para mostrar&quot;);&#10;                    }&#10;                });&#10;            } else {&#10;                android.util.Log.d(&quot;HomeDashboard&quot;, &quot;onBindViewHolder - Solicitud &quot; + s.id + &quot; - Usando cache existente: &quot; +&#10;                    lc.lat + &quot;,&quot; + lc.lon);&#10;                String textoUbicacion = formatUbicacion(lc.lat, lc.lon, lc.whenIso);&#10;                android.util.Log.d(&quot;HomeDashboard&quot;, &quot;onBindViewHolder - Solicitud &quot; + s.id + &quot; - Estableciendo texto: '&quot; + textoUbicacion + &quot;'&quot;);&#10;&#10;                // FORZAR VISIBILIDAD Y ACTUALIZACIÓN AGRESIVA DEL TEXTVIEW&#10;                h.tvUbicacion.setVisibility(View.VISIBLE);&#10;                h.tvUbicacion.setText(textoUbicacion);&#10;                h.tvUbicacion.setTextColor(0xFF000000); // Negro sólido&#10;                h.tvUbicacion.setTextSize(14); // Tamaño visible&#10;                h.tvUbicacion.invalidate();&#10;                h.tvUbicacion.requestLayout();&#10;&#10;                // FORZAR ACTUALIZACIÓN DE TODO EL CONTENEDOR&#10;                h.itemView.invalidate();&#10;                h.itemView.requestLayout();&#10;&#10;                // POST ADICIONAL PARA GARANTIZAR RENDERIZADO&#10;                h.itemView.post(() -&gt; {&#10;                    h.tvUbicacion.setVisibility(View.VISIBLE);&#10;                    h.tvUbicacion.setText(textoUbicacion);&#10;                    h.tvUbicacion.invalidate();&#10;                });&#10;&#10;                android.util.Log.d(&quot;HomeDashboard&quot;, &quot;onBindViewHolder - Solicitud &quot; + s.id + &quot; - TextView actualizado. Texto actual: '&quot; + h.tvUbicacion.getText() + &quot;'&quot;);&#10;                android.util.Log.d(&quot;HomeDashboard&quot;, &quot;onBindViewHolder - Solicitud &quot; + s.id + &quot; - TextView visibilidad: &quot; +&#10;                    (h.tvUbicacion.getVisibility() == View.VISIBLE ? &quot;VISIBLE&quot; : &quot;HIDDEN/GONE&quot;));&#10;&#10;                h.loadSnapshot(lc.lat, lc.lon, null, MAPS_KEY);&#10;            }&#10;        }&#10;&#10;        private String formatUbicacion(Double lat, Double lon, String whenIso){&#10;            android.util.Log.d(&quot;HomeDashboard&quot;, &quot;formatUbicacion llamado con: lat=&quot; + lat + &quot;, lon=&quot; + lon + &quot;, whenIso=&quot; + whenIso);&#10;&#10;            if (lat==null||lon==null) {&#10;                android.util.Log.d(&quot;HomeDashboard&quot;, &quot;formatUbicacion devolviendo: 'Recolector: —' (coordenadas null)&quot;);&#10;                return &quot;Recolector: —&quot;;&#10;            }&#10;&#10;            String delta = formatDelta(whenIso);&#10;            // CAMBIO: Dejar claro que es la ubicación actual del RECOLECTOR, no el destino&#10;            String resultado = String.format(Locale.getDefault(), &quot;Recolector en: %.5f, %.5f%s&quot;, lat, lon, delta.isEmpty()?&quot;&quot;:&quot; (&quot;+delta+&quot;)&quot;);&#10;            android.util.Log.d(&quot;HomeDashboard&quot;, &quot;formatUbicacion devolviendo: '&quot; + resultado + &quot;'&quot;);&#10;&#10;            return resultado;&#10;        }&#10;&#10;        private static String nn(String s) { return (s == null || s.trim().isEmpty()) ? &quot;—&quot; : s.trim(); }&#10;&#10;        private static String meta(String notas, String key) {&#10;            if (notas == null) return &quot;&quot;;&#10;            Pattern p = Pattern.compile(&#10;                    &quot;\\b&quot; + Pattern.quote(key) + &quot;\\s*:\\s*(.*?)\\s*(?:\\|\\s*|(?=[A-ZÁÉÍÓÚÑ][\\wÁÉÍÓÚÑáéíóúñ ]*:\\s*)|$)&quot;,&#10;                    Pattern.CASE_INSENSITIVE | Pattern.DOTALL&#10;            );&#10;            Matcher m = p.matcher(notas);&#10;            if (m.find()) return m.group(1).trim();&#10;&#10;            Pattern p2 = Pattern.compile(&quot;\\b&quot; + Pattern.quote(key) + &quot;\\s*:\\s*(.*)$&quot;,&#10;                    Pattern.CASE_INSENSITIVE | Pattern.DOTALL);&#10;            Matcher m2 = p2.matcher(notas);&#10;            return m2.find() ? m2.group(1).trim() : &quot;&quot;;&#10;        }&#10;&#10;        private static String firstNonEmpty(String... arr) {&#10;            if (arr == null) return &quot;&quot;;&#10;            for (String s : arr) if (s != null &amp;&amp; !s.trim().isEmpty()) return s.trim();&#10;            return &quot;&quot;;&#10;        }&#10;&#10;        private static String normalizeAddress(String raw) {&#10;            if (raw == null) return &quot;—&quot;;&#10;            String[] parts = raw.split(&quot;,&quot;);&#10;            List&lt;String&gt; cleaned = new ArrayList&lt;&gt;();&#10;            Set&lt;String&gt; seenCanon = new LinkedHashSet&lt;&gt;();&#10;            String prevCanon = null;&#10;&#10;            for (String p : parts) {&#10;                String t = p.trim();&#10;                if (t.isEmpty()) continue;&#10;                String canon = java.text.Normalizer.normalize(t, java.text.Normalizer.Form.NFD)&#10;                        .replaceAll(&quot;\\p{InCombiningDiacriticalMarks}+&quot;, &quot;&quot;)&#10;                        .replaceAll(&quot;[^a-zA-Z\\s]&quot;, &quot;&quot;)&#10;                        .toLowerCase(Locale.ROOT)&#10;                        .replaceAll(&quot;\\s+&quot;, &quot; &quot;)&#10;                        .trim();&#10;                if (prevCanon != null &amp;&amp; (canon.equals(prevCanon) ||&#10;                        canon.startsWith(prevCanon) || prevCanon.startsWith(canon))) continue;&#10;                if (seenCanon.contains(canon)) continue;&#10;                cleaned.add(t);&#10;                seenCanon.add(canon);&#10;                prevCanon = canon;&#10;            }&#10;            return cleaned.isEmpty() ? raw.trim() : TextUtils.join(&quot;, &quot;, cleaned);&#10;        }&#10;&#10;        private static String prettyEta(String iso){&#10;            if (iso == null || iso.trim().isEmpty()) return &quot;—&quot;;&#10;            int t = iso.indexOf('T');&#10;            if (t &gt;= 0 &amp;&amp; iso.length() &gt;= t + 6) return iso.substring(t + 1, t + 6);&#10;            return iso;&#10;        }&#10;&#10;        private static String formatDelta(String iso){&#10;            if (iso == null) return &quot;&quot;;&#10;            try {&#10;                // intento parse simple&#10;                String base = iso.replace('Z',' ').trim();&#10;                // soporta formato con zona: tomamos primeros 19 caracteres yyyy-MM-ddTHH:mm:ss&#10;                if (base.length() &gt;= 19) base = base.substring(0,19);&#10;                java.text.SimpleDateFormat f = new java.text.SimpleDateFormat(&quot;yyyy-MM-dd'T'HH:mm:ss&quot;, Locale.getDefault());&#10;                long t = f.parse(base).getTime();&#10;                long now = System.currentTimeMillis();&#10;                long diff = Math.max(0, now - t);&#10;                long mins = diff / 60000L;&#10;                if (mins &lt; 1) return &quot;hace instantes&quot;;&#10;                if (mins &lt; 60) return &quot;hace &quot; + mins + &quot; min&quot;;&#10;                long hrs = mins / 60; if (hrs &lt; 24) return &quot;hace &quot; + hrs + &quot; h&quot;;&#10;                long dias = hrs / 24; return &quot;hace &quot; + dias + &quot; d&quot;;&#10;            } catch (Exception ignore) {}&#10;            return &quot;&quot;;&#10;        }&#10;&#10;        interface ItemClick { void openMapa(long solicitudId); }&#10;        private ItemClick cb;&#10;        void setOnItemClick(ItemClick cb){ this.cb = cb; }&#10;        @Override public int getItemCount(){ return data.size(); }&#10;    }&#10;&#10;    private static class VH extends RecyclerView.ViewHolder {&#10;        TextView tvGuiaEstado, tvRango, tvEta, tvDireccion, tvDestino, tvUbicacion;&#10;        ImageView ivMap;&#10;        VH(@NonNull View itemView) {&#10;            super(itemView);&#10;            tvGuiaEstado = itemView.findViewById(R.id.tvGuiaEstado);&#10;            tvRango      = itemView.findViewById(R.id.tvRango);&#10;            tvEta        = itemView.findViewById(R.id.tvEta);&#10;            tvDireccion  = itemView.findViewById(R.id.tvDireccion);&#10;            tvDestino    = itemView.findViewById(R.id.tvDestino);&#10;            tvUbicacion  = itemView.findViewById(R.id.tvUbicacion);&#10;            ivMap        = itemView.findViewById(R.id.ivMapPreview);&#10;        }&#10;        void loadSnapshot(Double lat, Double lon, Double destLat, String key) {&#10;            if (ivMap==null) return;&#10;            if (lat==null || lon==null || key==null || key.isEmpty()) {&#10;                ivMap.setImageResource(R.drawable.ic_launcher_background);&#10;                return;&#10;            }&#10;            StringBuilder url = new StringBuilder(&quot;https://maps.googleapis.com/maps/api/staticmap?&quot;);&#10;            url.append(&quot;center=&quot;).append(lat).append(&quot;,&quot;).append(lon)&#10;               .append(&quot;&amp;zoom=13&amp;size=400x200&amp;scale=2&amp;maptype=roadmap&quot;)&#10;               .append(&quot;&amp;markers=color:blue%7C&quot;).append(lat).append(&quot;,&quot;).append(lon);&#10;            // destino opcional no implementado (sin destLon real)&#10;            url.append(&quot;&amp;key=&quot;).append(key);&#10;            new Thread(() -&gt; {&#10;                try (InputStream is = new URL(url.toString()).openStream()) {&#10;                    Bitmap bmp = BitmapFactory.decodeStream(is);&#10;                    ivMap.post(() -&gt; ivMap.setImageBitmap(bmp));&#10;                } catch (Exception ignore) {}&#10;            }).start();&#10;        }&#10;    }&#10;&#10;    // Exponer método para configurar callback tras cargar panel&#10;    private void prepararClicks() {&#10;        if (adapter != null) adapter.setOnItemClick(sid -&gt; {&#10;            if (navController != null) {&#10;                try {&#10;                    Bundle b = new Bundle(); b.putLong(&quot;solicitudId&quot;, sid);&#10;                    navController.navigate(R.id.action_home_to_solicitudMapa, b);&#10;                } catch (Exception ignored) {}&#10;            }&#10;        });&#10;    }&#10;&#10;    private void cargarPanel() {&#10;        if (swRefresh != null) swRefresh.setRefreshing(true);&#10;        Executors.newSingleThreadExecutor().execute(() -&gt; {&#10;            try {&#10;                AppDatabase db = AppDatabase.getInstance(requireContext());&#10;                SessionManager sm = new SessionManager(requireContext());&#10;                String email = sm.getEmail();&#10;                if (TextUtils.isEmpty(email)) {&#10;                    runOnUi(() -&gt; {&#10;                        if (swRefresh != null) swRefresh.setRefreshing(false);&#10;                        Toast.makeText(requireContext(), &quot;Sesión no válida&quot;, Toast.LENGTH_SHORT).show();&#10;                    });&#10;                    return;&#10;                }&#10;                com.hfad.encomiendas.data.User u = db.userDao().findByEmail(email);&#10;                if (u == null) {&#10;                    runOnUi(() -&gt; {&#10;                        if (swRefresh != null) swRefresh.setRefreshing(false);&#10;                        Toast.makeText(requireContext(), &quot;Usuario no encontrado&quot;, Toast.LENGTH_SHORT).show();&#10;                    });&#10;                    return;&#10;                }&#10;&#10;                int cPend = db.solicitudDao().countByEstado(u.id, &quot;PENDIENTE&quot;);&#10;                int cAsig = db.solicitudDao().countByEstado(u.id, &quot;ASIGNADA&quot;);&#10;                int cReco = db.solicitudDao().countByEstado(u.id, &quot;RECOLECTADA&quot;);&#10;&#10;                List&lt;SolicitudDao.SolicitudConEta&gt; ultimas = db.solicitudDao().listAllByUserWithEta(u.id, 20);&#10;&#10;                runOnUi(() -&gt; {&#10;                    tvCountPendientes.setText(String.valueOf(cPend));&#10;                    tvCountAsignadas.setText(String.valueOf(cAsig));&#10;                    tvCountRecolectadas.setText(String.valueOf(cReco));&#10;&#10;                    adapter.setData(ultimas);&#10;                    adapter.refreshLocationsAsync();&#10;                    tvEmpty.setVisibility(adapter.getItemCount() == 0 ? View.VISIBLE : View.GONE);&#10;                    if (swRefresh != null) swRefresh.setRefreshing(false);&#10;                    prepararClicks();&#10;                });&#10;&#10;            } catch (Exception e) {&#10;                runOnUi(() -&gt; {&#10;                    if (swRefresh != null) swRefresh.setRefreshing(false);&#10;                    Toast.makeText(requireContext(), &quot;Error: &quot; + e.getMessage(), Toast.LENGTH_SHORT).show();&#10;                });&#10;            }&#10;        });&#10;    }&#10;&#10;    // Optimizar MapView en reciclado&#10;    @Override&#10;    public void onDestroyView() {&#10;        super.onDestroyView();&#10;        if (rvSolicitudes != null) {&#10;            RecyclerView.Adapter a = rvSolicitudes.getAdapter();&#10;            if (a instanceof UltimasAdapter) {&#10;                // no acceso directo a los holders ya reciclados; rely en GC&#10;            }&#10;        }&#10;    }&#10;&#10;    private void runOnUi(Runnable r) { if (!isAdded()) return; requireActivity().runOnUiThread(r); }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/hfad/encomiendas/ui/SolicitudMapaFragment.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/hfad/encomiendas/ui/SolicitudMapaFragment.java" />
              <option name="updatedContent" value="package com.hfad.encomiendas.ui;&#10;&#10;import android.os.Bundle;&#10;import android.text.TextUtils;&#10;import android.view.LayoutInflater;&#10;import android.view.View;&#10;import android.view.ViewGroup;&#10;import android.widget.TextView;&#10;&#10;import androidx.annotation.NonNull;&#10;import androidx.annotation.Nullable;&#10;import androidx.fragment.app.Fragment;&#10;&#10;import com.google.android.gms.maps.CameraUpdateFactory;&#10;import com.google.android.gms.maps.GoogleMap;&#10;import com.google.android.gms.maps.MapView;&#10;import com.google.android.gms.maps.OnMapReadyCallback;&#10;import com.google.android.gms.maps.model.LatLng;&#10;import com.google.android.gms.maps.model.Marker;&#10;import com.google.android.gms.maps.model.MarkerOptions;&#10;import com.hfad.encomiendas.R;&#10;import com.hfad.encomiendas.data.AppDatabase;&#10;import com.hfad.encomiendas.data.TrackingEventDao;&#10;&#10;import java.text.SimpleDateFormat;&#10;import java.util.Locale;&#10;import java.util.concurrent.Executors;&#10;&#10;public class SolicitudMapaFragment extends Fragment implements OnMapReadyCallback {&#10;&#10;    private long solicitudId = -1;&#10;    private MapView mapView; private GoogleMap gMap; private Marker markerRecolector;&#10;    private TextView tvInfo, btnCerrar;&#10;    private View fabCenter;&#10;    private Double lastLat, lastLon; private String lastWhen;&#10;&#10;    private final Runnable refresco = new Runnable() {&#10;        @Override public void run() { cargarUbicacion(); mapView.postDelayed(this, 30_000); }&#10;    };&#10;&#10;    @Nullable @Override&#10;    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {&#10;        return inflater.inflate(R.layout.fragment_solicitud_mapa, container, false);&#10;    }&#10;&#10;    @Override&#10;    public void onViewCreated(@NonNull View v, @Nullable Bundle savedInstanceState) {&#10;        super.onViewCreated(v, savedInstanceState);&#10;        solicitudId = getArguments() != null ? getArguments().getLong(&quot;solicitudId&quot;, -1) : -1;&#10;        mapView = v.findViewById(R.id.mapFull);&#10;        tvInfo  = v.findViewById(R.id.tvInfo);&#10;        btnCerrar = v.findViewById(R.id.btnCerrar);&#10;        fabCenter = v.findViewById(R.id.fabCenter);&#10;&#10;        if (mapView != null) {&#10;            mapView.onCreate(savedInstanceState);&#10;            mapView.getMapAsync(this);&#10;        }&#10;        if (btnCerrar != null) btnCerrar.setOnClickListener(vw -&gt; requireActivity().onBackPressed());&#10;        if (fabCenter != null) fabCenter.setOnClickListener(vw -&gt; center());&#10;        cargarUbicacion();&#10;    }&#10;&#10;    private void cargarUbicacion() {&#10;        if (solicitudId &lt;= 0 || !isAdded()) return;&#10;        Executors.newSingleThreadExecutor().execute(() -&gt; {&#10;            try {&#10;                TrackingEventDao.LastLoc loc = AppDatabase.getInstance(requireContext())&#10;                        .trackingEventDao().lastLocationForShipment(solicitudId);&#10;                if (loc != null &amp;&amp; loc.lat != null &amp;&amp; loc.lon != null) {&#10;                    lastLat = loc.lat; lastLon = loc.lon; lastWhen = loc.whenIso;&#10;                    if (getActivity() != null) getActivity().runOnUiThread(() -&gt; {&#10;                        actualizarUi(); pintar();&#10;                    });&#10;                }&#10;            } catch (Exception ignore) {}&#10;        });&#10;    }&#10;&#10;    private void actualizarUi() {&#10;        if (tvInfo == null) return;&#10;        String delta = deltaHuman(lastWhen);&#10;        tvInfo.setText(&quot;Recolector: &quot; + (lastLat==null?&quot;-&quot;:String.format(Locale.getDefault(),&quot;%.5f, %.5f&quot;, lastLat,lastLon)) + (TextUtils.isEmpty(delta)?&quot;&quot;:&quot; (&quot;+delta+&quot;)&quot;));&#10;    }&#10;&#10;    private String deltaHuman(String iso) {&#10;        if (iso == null) return &quot;&quot;;&#10;        try {&#10;            String base = iso.replace('Z',' ').trim();&#10;            if (base.length() &gt;= 19) base = base.substring(0,19);&#10;            SimpleDateFormat f = new SimpleDateFormat(&quot;yyyy-MM-dd'T'HH:mm:ss&quot;, Locale.getDefault());&#10;            long t = f.parse(base).getTime();&#10;            long diff = Math.max(0, System.currentTimeMillis() - t);&#10;            long mins = diff/60000L;&#10;            if (mins &lt; 1) return &quot;hace instantes&quot;;&#10;            if (mins &lt; 60) return &quot;hace &quot;+mins+&quot; min&quot;;&#10;            long hrs=mins/60; if (hrs&lt;24) return &quot;hace &quot;+hrs+&quot; h&quot;;&#10;            long d=hrs/24; return &quot;hace &quot;+d+&quot; d&quot;;&#10;        } catch(Exception e){return &quot;&quot;;}&#10;    }&#10;&#10;    private void pintar() {&#10;        if (gMap == null || lastLat==null || lastLon==null) return;&#10;        LatLng p = new LatLng(lastLat, lastLon);&#10;        if (markerRecolector == null) {&#10;            markerRecolector = gMap.addMarker(new MarkerOptions().position(p).title(&quot;Recolector&quot;));&#10;        } else markerRecolector.setPosition(p);&#10;        gMap.animateCamera(CameraUpdateFactory.newLatLngZoom(p, 15f));&#10;    }&#10;&#10;    private void center() { pintar(); }&#10;&#10;    @Override public void onMapReady(@NonNull GoogleMap googleMap) { this.gMap = googleMap; pintar(); }&#10;&#10;    @Override public void onResume() { super.onResume(); if (mapView!=null) mapView.onResume(); mapView.postDelayed(refresco, 30_000); }&#10;    @Override public void onPause() { super.onPause(); if (mapView!=null) mapView.onPause(); mapView.removeCallbacks(refresco); }&#10;    @Override public void onDestroyView() { super.onDestroyView(); if (mapView!=null) mapView.onDestroy(); }&#10;    @Override public void onLowMemory() { super.onLowMemory(); if (mapView!=null) mapView.onLowMemory(); }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/anim/slide_in_left.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/anim/slide_in_left.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:interpolator=&quot;@android:interpolator/fast_out_slow_in&quot;&gt;&#10;    &lt;translate&#10;        android:fromXDelta=&quot;-100%&quot;&#10;        android:toXDelta=&quot;0%&quot;&#10;        android:duration=&quot;250&quot; /&gt;&#10;    &lt;alpha android:fromAlpha=&quot;0&quot; android:toAlpha=&quot;1&quot; android:duration=&quot;250&quot;/&gt;&#10;&lt;/set&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/anim/slide_in_right.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/anim/slide_in_right.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:interpolator=&quot;@android:interpolator/fast_out_slow_in&quot;&gt;&#10;    &lt;translate&#10;        android:fromXDelta=&quot;100%&quot;&#10;        android:toXDelta=&quot;0%&quot;&#10;        android:duration=&quot;250&quot; /&gt;&#10;    &lt;alpha android:fromAlpha=&quot;0&quot; android:toAlpha=&quot;1&quot; android:duration=&quot;250&quot;/&gt;&#10;&lt;/set&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/anim/slide_out_left.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/anim/slide_out_left.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:interpolator=&quot;@android:interpolator/fast_out_linear_in&quot;&gt;&#10;    &lt;translate&#10;        android:fromXDelta=&quot;0%&quot;&#10;        android:toXDelta=&quot;-100%&quot;&#10;        android:duration=&quot;250&quot; /&gt;&#10;    &lt;alpha android:fromAlpha=&quot;1&quot; android:toAlpha=&quot;0&quot; android:duration=&quot;250&quot;/&gt;&#10;&lt;/set&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/anim/slide_out_right.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/anim/slide_out_right.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:interpolator=&quot;@android:interpolator/fast_out_linear_in&quot;&gt;&#10;    &lt;translate&#10;        android:fromXDelta=&quot;0%&quot;&#10;        android:toXDelta=&quot;100%&quot;&#10;        android:duration=&quot;250&quot; /&gt;&#10;    &lt;alpha android:fromAlpha=&quot;1&quot; android:toAlpha=&quot;0&quot; android:duration=&quot;250&quot;/&gt;&#10;&lt;/set&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/fragment_detalle_entrega.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/fragment_detalle_entrega.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;androidx.core.widget.NestedScrollView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    android:fillViewport=&quot;true&quot;&gt;&#10;&#10;    &lt;LinearLayout&#10;        android:orientation=&quot;vertical&quot;&#10;        android:padding=&quot;16dp&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&gt;&#10;&#10;        &lt;com.google.android.material.card.MaterialCardView&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            app:cardCornerRadius=&quot;16dp&quot;&#10;            app:strokeWidth=&quot;1dp&quot;&#10;            android:layout_marginBottom=&quot;12dp&quot;&gt;&#10;            &lt;LinearLayout&#10;                android:orientation=&quot;vertical&quot;&#10;                android:padding=&quot;16dp&quot;&#10;                android:layout_width=&quot;match_parent&quot;&#10;                android:layout_height=&quot;wrap_content&quot;&gt;&#10;                &lt;TextView&#10;                    android:id=&quot;@+id/tvTitulo&quot;&#10;                    android:layout_width=&quot;wrap_content&quot;&#10;                    android:layout_height=&quot;wrap_content&quot;&#10;                    android:textStyle=&quot;bold&quot;&#10;                    android:text=&quot;Entrega&quot;&#10;                    android:textAppearance=&quot;@style/TextAppearance.Material3.TitleMedium&quot;/&gt;&#10;                &lt;TextView&#10;                    android:id=&quot;@+id/tvEstado&quot;&#10;                    android:layout_width=&quot;wrap_content&quot;&#10;                    android:layout_height=&quot;wrap_content&quot;&#10;                    android:layout_marginTop=&quot;4dp&quot;&#10;                    android:text=&quot;—&quot;/&gt;&#10;            &lt;/LinearLayout&gt;&#10;        &lt;/com.google.android.material.card.MaterialCardView&gt;&#10;&#10;        &lt;com.google.android.material.card.MaterialCardView&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            app:cardCornerRadius=&quot;16dp&quot;&#10;            app:strokeWidth=&quot;1dp&quot;&#10;            android:layout_marginBottom=&quot;12dp&quot;&gt;&#10;            &lt;LinearLayout&#10;                android:orientation=&quot;vertical&quot;&#10;                android:padding=&quot;16dp&quot;&#10;                android:layout_width=&quot;match_parent&quot;&#10;                android:layout_height=&quot;wrap_content&quot;&gt;&#10;                &lt;FrameLayout&#10;                    android:id=&quot;@+id/map_container_entrega&quot;&#10;                    android:layout_width=&quot;match_parent&quot;&#10;                    android:layout_height=&quot;220dp&quot;/&gt;&#10;                &lt;com.google.android.material.chip.Chip&#10;                    android:id=&quot;@+id/chipDistance&quot;&#10;                    style=&quot;@style/Widget.Material3.Chip.Assist&quot;&#10;                    android:layout_width=&quot;wrap_content&quot;&#10;                    android:layout_height=&quot;wrap_content&quot;&#10;                    android:layout_marginTop=&quot;8dp&quot;&#10;                    android:text=&quot;—&quot;/&gt;&#10;                &lt;TextView&#10;                    android:id=&quot;@+id/tvEta&quot;&#10;                    android:layout_width=&quot;wrap_content&quot;&#10;                    android:layout_height=&quot;wrap_content&quot;&#10;                    android:padding=&quot;8dp&quot;&#10;                    android:text=&quot;ETA: —&quot;/&gt;&#10;                &lt;androidx.recyclerview.widget.RecyclerView&#10;                    android:id=&quot;@+id/rvTimeline&quot;&#10;                    android:layout_width=&quot;match_parent&quot;&#10;                    android:layout_height=&quot;wrap_content&quot;&#10;                    android:nestedScrollingEnabled=&quot;false&quot;/&gt;&#10;                &lt;LinearLayout&#10;                    android:layout_width=&quot;match_parent&quot;&#10;                    android:layout_height=&quot;wrap_content&quot;&#10;                    android:orientation=&quot;horizontal&quot;&#10;                    android:layout_marginTop=&quot;12dp&quot;&gt;&#10;                    &lt;com.google.android.material.button.MaterialButton&#10;                        android:id=&quot;@+id/btnIniciarRuta&quot;&#10;                        android:layout_width=&quot;0dp&quot;&#10;                        android:layout_height=&quot;wrap_content&quot;&#10;                        android:layout_weight=&quot;1&quot;&#10;                        android:text=&quot;Iniciar ruta&quot;/&gt;&#10;                    &lt;Space android:layout_width=&quot;12dp&quot; android:layout_height=&quot;1dp&quot;/&gt;&#10;                    &lt;com.google.android.material.button.MaterialButton&#10;                        android:id=&quot;@+id/btnMarcarEntregado&quot;&#10;                        style=&quot;@style/Widget.Material3.Button.FilledTonalButton&quot;&#10;                        android:layout_width=&quot;0dp&quot;&#10;                        android:layout_height=&quot;wrap_content&quot;&#10;                        android:layout_weight=&quot;1&quot;&#10;                        android:text=&quot;Entregado&quot;/&gt;&#10;                &lt;/LinearLayout&gt;&#10;            &lt;/LinearLayout&gt;&#10;        &lt;/com.google.android.material.card.MaterialCardView&gt;&#10;    &lt;/LinearLayout&gt;&#10;&lt;/androidx.core.widget.NestedScrollView&gt;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;androidx.core.widget.NestedScrollView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    android:fillViewport=&quot;true&quot;&gt;&#10;&#10;    &lt;LinearLayout&#10;        android:orientation=&quot;vertical&quot;&#10;        android:padding=&quot;16dp&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&gt;&#10;&#10;        &lt;com.google.android.material.card.MaterialCardView&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            app:cardCornerRadius=&quot;16dp&quot;&#10;            app:strokeWidth=&quot;1dp&quot;&#10;            android:layout_marginBottom=&quot;12dp&quot;&gt;&#10;            &lt;LinearLayout&#10;                android:orientation=&quot;vertical&quot;&#10;                android:padding=&quot;16dp&quot;&#10;                android:layout_width=&quot;match_parent&quot;&#10;                android:layout_height=&quot;wrap_content&quot;&gt;&#10;                &lt;TextView&#10;                    android:id=&quot;@+id/tvTitulo&quot;&#10;                    android:layout_width=&quot;wrap_content&quot;&#10;                    android:layout_height=&quot;wrap_content&quot;&#10;                    android:textStyle=&quot;bold&quot;&#10;                    android:text=&quot;Entrega&quot;&#10;                    android:textAppearance=&quot;@style/TextAppearance.Material3.TitleMedium&quot;/&gt;&#10;                &lt;TextView&#10;                    android:id=&quot;@+id/tvEstado&quot;&#10;                    android:layout_width=&quot;wrap_content&quot;&#10;                    android:layout_height=&quot;wrap_content&quot;&#10;                    android:layout_marginTop=&quot;4dp&quot;&#10;                    android:text=&quot;—&quot;/&gt;&#10;            &lt;/LinearLayout&gt;&#10;        &lt;/com.google.android.material.card.MaterialCardView&gt;&#10;&#10;        &lt;com.google.android.material.card.MaterialCardView&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            app:cardCornerRadius=&quot;16dp&quot;&#10;            app:strokeWidth=&quot;1dp&quot;&#10;            android:layout_marginBottom=&quot;12dp&quot;&gt;&#10;            &lt;LinearLayout&#10;                android:orientation=&quot;vertical&quot;&#10;                android:padding=&quot;16dp&quot;&#10;                android:layout_width=&quot;match_parent&quot;&#10;                android:layout_height=&quot;wrap_content&quot;&gt;&#10;                &lt;FrameLayout&#10;                    android:id=&quot;@+id/map_container_entrega&quot;&#10;                    android:layout_width=&quot;match_parent&quot;&#10;                    android:layout_height=&quot;220dp&quot;/&gt;&#10;                &lt;com.google.android.material.chip.Chip&#10;                    android:id=&quot;@+id/chipDistance&quot;&#10;                    style=&quot;@style/Widget.Material3.Chip.Assist&quot;&#10;                    android:layout_width=&quot;wrap_content&quot;&#10;                    android:layout_height=&quot;wrap_content&quot;&#10;                    android:layout_marginTop=&quot;8dp&quot;&#10;                    android:text=&quot;—&quot;/&gt;&#10;                &lt;TextView&#10;                    android:id=&quot;@+id/tvEta&quot;&#10;                    android:layout_width=&quot;wrap_content&quot;&#10;                    android:layout_height=&quot;wrap_content&quot;&#10;                    android:padding=&quot;8dp&quot;&#10;                    android:text=&quot;ETA: —&quot;/&gt;&#10;                &lt;androidx.recyclerview.widget.RecyclerView&#10;                    android:id=&quot;@+id/rvTimeline&quot;&#10;                    android:layout_width=&quot;match_parent&quot;&#10;                    android:layout_height=&quot;wrap_content&quot;&#10;                    android:nestedScrollingEnabled=&quot;false&quot;/&gt;&#10;                &lt;LinearLayout&#10;                    android:layout_width=&quot;match_parent&quot;&#10;                    android:layout_height=&quot;wrap_content&quot;&#10;                    android:orientation=&quot;horizontal&quot;&#10;                    android:layout_marginTop=&quot;12dp&quot;&gt;&#10;                    &lt;com.google.android.material.button.MaterialButton&#10;                        android:id=&quot;@+id/btnIniciarRuta&quot;&#10;                        android:layout_width=&quot;0dp&quot;&#10;                        android:layout_height=&quot;wrap_content&quot;&#10;                        android:layout_weight=&quot;1&quot;&#10;                        android:text=&quot;Iniciar ruta&quot;/&gt;&#10;                    &lt;Space android:layout_width=&quot;12dp&quot; android:layout_height=&quot;1dp&quot;/&gt;&#10;                    &lt;com.google.android.material.button.MaterialButton&#10;                        android:id=&quot;@+id/btnMarcarEntregado&quot;&#10;                        android:layout_width=&quot;0dp&quot;&#10;                        android:layout_height=&quot;wrap_content&quot;&#10;                        android:layout_weight=&quot;1&quot;&#10;                        android:text=&quot;Entregado&quot;/&gt;&#10;                &lt;/LinearLayout&gt;&#10;            &lt;/LinearLayout&gt;&#10;        &lt;/com.google.android.material.card.MaterialCardView&gt;&#10;    &lt;/LinearLayout&gt;&#10;&lt;/androidx.core.widget.NestedScrollView&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/fragment_recoleccion_mapa.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/fragment_recoleccion_mapa.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&gt;&#10;&#10;    &lt;com.google.android.gms.maps.MapView&#10;        android:id=&quot;@+id/mapFullReco&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;match_parent&quot;/&gt;&#10;&#10;    &lt;LinearLayout&#10;        android:orientation=&quot;horizontal&quot;&#10;        android:background=&quot;#66000000&quot;&#10;        android:padding=&quot;8dp&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&gt;&#10;        &lt;ImageButton&#10;            android:id=&quot;@+id/btnBackReco&quot;&#10;            android:layout_width=&quot;40dp&quot;&#10;            android:layout_height=&quot;40dp&quot;&#10;            android:background=&quot;@android:color/transparent&quot;&#10;            android:src=&quot;@android:drawable/ic_menu_close_clear_cancel&quot;&#10;            android:contentDescription=&quot;Cerrar&quot;/&gt;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/tvStatusReco&quot;&#10;            android:layout_width=&quot;wrap_content&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:layout_gravity=&quot;center_vertical&quot;&#10;            android:layout_marginStart=&quot;12dp&quot;&#10;            android:textColor=&quot;@android:color/white&quot;&#10;            android:text=&quot;Cargando...&quot;/&gt;&#10;    &lt;/LinearLayout&gt;&#10;&#10;    &lt;com.google.android.material.floatingactionbutton.FloatingActionButton&#10;        android:id=&quot;@+id/fabCenterReco&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_gravity=&quot;bottom|end&quot;&#10;        android:layout_margin=&quot;16dp&quot;&#10;        android:contentDescription=&quot;Centrar&quot;&#10;        android:src=&quot;@android:drawable/ic_menu_mylocation&quot;/&gt;&#10;&#10;&lt;/FrameLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/fragment_solicitud_mapa.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/fragment_solicitud_mapa.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&gt;&#10;&#10;    &lt;com.google.android.gms.maps.MapView&#10;        android:id=&quot;@+id/mapFull&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;match_parent&quot;/&gt;&#10;&#10;    &lt;LinearLayout&#10;        android:orientation=&quot;horizontal&quot;&#10;        android:padding=&quot;12dp&quot;&#10;        android:background=&quot;#66000000&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_gravity=&quot;top&quot;&gt;&#10;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/tvInfo&quot;&#10;            android:layout_width=&quot;0dp&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:layout_weight=&quot;1&quot;&#10;            android:textColor=&quot;#FFFFFF&quot;&#10;            android:textSize=&quot;14sp&quot;&#10;            android:text=&quot;Cargando...&quot;/&gt;&#10;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/btnCerrar&quot;&#10;            android:layout_width=&quot;wrap_content&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:text=&quot;Cerrar&quot;&#10;            android:textColor=&quot;#FFFFFF&quot;&#10;            android:padding=&quot;8dp&quot;&#10;            android:background=&quot;@android:color/transparent&quot;/&gt;&#10;    &lt;/LinearLayout&gt;&#10;&#10;    &lt;com.google.android.material.floatingactionbutton.FloatingActionButton&#10;        android:id=&quot;@+id/fabCenter&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_gravity=&quot;bottom|end&quot;&#10;        android:layout_margin=&quot;16dp&quot;&#10;        android:contentDescription=&quot;Centrar&quot;&#10;        android:src=&quot;@android:drawable/ic_menu_mylocation&quot;/&gt;&#10;&#10;&lt;/FrameLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/raw/map_dark.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/raw/map_dark.json" />
              <option name="updatedContent" value="[&#10;  {&#10;    &quot;elementType&quot;: &quot;geometry&quot;,&#10;    &quot;stylers&quot;: [ { &quot;color&quot;: &quot;#212121&quot; } ]&#10;  },&#10;  {&#10;    &quot;elementType&quot;: &quot;labels.icon&quot;,&#10;    &quot;stylers&quot;: [ { &quot;visibility&quot;: &quot;off&quot; } ]&#10;  },&#10;  {&#10;    &quot;elementType&quot;: &quot;labels.text.fill&quot;,&#10;    &quot;stylers&quot;: [ { &quot;color&quot;: &quot;#757575&quot; } ]&#10;  },&#10;  {&#10;    &quot;elementType&quot;: &quot;labels.text.stroke&quot;,&#10;    &quot;stylers&quot;: [ { &quot;color&quot;: &quot;#212121&quot; } ]&#10;  },&#10;  {&#10;    &quot;featureType&quot;: &quot;administrative&quot;,&#10;    &quot;elementType&quot;: &quot;geometry&quot;,&#10;    &quot;stylers&quot;: [ { &quot;color&quot;: &quot;#757575&quot; } ]&#10;  },&#10;  {&#10;    &quot;featureType&quot;: &quot;poi&quot;,&#10;    &quot;elementType&quot;: &quot;labels.text.fill&quot;,&#10;    &quot;stylers&quot;: [ { &quot;color&quot;: &quot;#bdbdbd&quot; } ]&#10;  },&#10;  {&#10;    &quot;featureType&quot;: &quot;poi.park&quot;,&#10;    &quot;elementType&quot;: &quot;geometry&quot;,&#10;    &quot;stylers&quot;: [ { &quot;color&quot;: &quot;#181818&quot; } ]&#10;  },&#10;  {&#10;    &quot;featureType&quot;: &quot;poi.park&quot;,&#10;    &quot;elementType&quot;: &quot;labels.text.fill&quot;,&#10;    &quot;stylers&quot;: [ { &quot;color&quot;: &quot;#616161&quot; } ]&#10;  },&#10;  {&#10;    &quot;featureType&quot;: &quot;poi.park&quot;,&#10;    &quot;elementType&quot;: &quot;labels.text.stroke&quot;,&#10;    &quot;stylers&quot;: [ { &quot;color&quot;: &quot;#1b1b1b&quot; } ]&#10;  },&#10;  {&#10;    &quot;featureType&quot;: &quot;road&quot;,&#10;    &quot;elementType&quot;: &quot;geometry.fill&quot;,&#10;    &quot;stylers&quot;: [ { &quot;color&quot;: &quot;#2c2c2c&quot; } ]&#10;  },&#10;  {&#10;    &quot;featureType&quot;: &quot;road&quot;,&#10;    &quot;elementType&quot;: &quot;labels.text.fill&quot;,&#10;    &quot;stylers&quot;: [ { &quot;color&quot;: &quot;#8a8a8a&quot; } ]&#10;  },&#10;  {&#10;    &quot;featureType&quot;: &quot;road.arterial&quot;,&#10;    &quot;elementType&quot;: &quot;geometry&quot;,&#10;    &quot;stylers&quot;: [ { &quot;color&quot;: &quot;#373737&quot; } ]&#10;  },&#10;  {&#10;    &quot;featureType&quot;: &quot;road.highway&quot;,&#10;    &quot;elementType&quot;: &quot;geometry&quot;,&#10;    &quot;stylers&quot;: [ { &quot;color&quot;: &quot;#3c3c3c&quot; } ]&#10;  },&#10;  {&#10;    &quot;featureType&quot;: &quot;road.highway.controlled_access&quot;,&#10;    &quot;elementType&quot;: &quot;geometry&quot;,&#10;    &quot;stylers&quot;: [ { &quot;color&quot;: &quot;#4e4e4e&quot; } ]&#10;  },&#10;  {&#10;    &quot;featureType&quot;: &quot;road.local&quot;,&#10;    &quot;elementType&quot;: &quot;labels.text.fill&quot;,&#10;    &quot;stylers&quot;: [ { &quot;color&quot;: &quot;#616161&quot; } ]&#10;  },&#10;  {&#10;    &quot;featureType&quot;: &quot;transit&quot;,&#10;    &quot;elementType&quot;: &quot;labels.text.fill&quot;,&#10;    &quot;stylers&quot;: [ { &quot;color&quot;: &quot;#757575&quot; } ]&#10;  },&#10;  {&#10;    &quot;featureType&quot;: &quot;water&quot;,&#10;    &quot;elementType&quot;: &quot;geometry&quot;,&#10;    &quot;stylers&quot;: [ { &quot;color&quot;: &quot;#000000&quot; } ]&#10;  },&#10;  {&#10;    &quot;featureType&quot;: &quot;water&quot;,&#10;    &quot;elementType&quot;: &quot;labels.text.fill&quot;,&#10;    &quot;stylers&quot;: [ { &quot;color&quot;: &quot;#3d3d3d&quot; } ]&#10;  }&#10;]&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>